{# --- JavaScript at the end --- #}
<script>
    // --- Global variables and functions for Unsaved Changes (moved out of DOMContentLoaded) ---
    let hasUnsavedChanges = false;
    let unsavedChangesAlert = null; // Will be assigned in DOMContentLoaded
    let configForm = null;          // Will be assigned in DOMContentLoaded
    let userHasInteracted = false;  // CRITICAL: Make this global so all event listeners can access it

    // --- NEW: Variable and function for Restart Alert ---
    let restartRequiredAlert = null;
    let restartRequired = false;    // Flag whether restart is required
    
    function showRestartRequiredAlert() {
        if (!restartRequiredAlert) restartRequiredAlert = document.getElementById('restart-required-alert');
        if (restartRequiredAlert && restartRequired) {
            restartRequiredAlert.classList.remove('force-hide');
            console.log('Restart alert is displayed (via classList.remove)');
        }
    }
    // --- End Restart Alert --- 

    function showUnsavedChangesAlert(requiresRestart = false) {
        console.log(`showUnsavedChangesAlert called with requiresRestart: ${requiresRestart}`);
        
        // Ensures that the element was found
        if (!unsavedChangesAlert) unsavedChangesAlert = document.getElementById('unsaved-changes-alert');
        
        // Only display if not yet displayed and element exists
        if (unsavedChangesAlert && !hasUnsavedChanges) {
            unsavedChangesAlert.classList.remove('force-hide');
            unsavedChangesAlert.style.display = 'flex'; // CRITICAL: Also set display style!
            hasUnsavedChanges = true;
            console.log('Unsaved changes alert is displayed (via classList.remove and style.display)');
        } else {
            console.log(`Alert not shown - unsavedChangesAlert: ${!!unsavedChangesAlert}, hasUnsavedChanges: ${hasUnsavedChanges}`);
        }
        
        // Set the restart flag if required
        if (requiresRestart) {
            restartRequired = true;
            console.log('Restart flag set');
        }
    }

    function hideUnsavedChangesAlert() {
        // Ensures that the element was found
        if (!unsavedChangesAlert) unsavedChangesAlert = document.getElementById('unsaved-changes-alert');
        
        if (unsavedChangesAlert) {
            // Primarily add class to hide it
            unsavedChangesAlert.classList.add('force-hide'); 
            unsavedChangesAlert.style.display = 'none'; // Also set display style for consistency
            console.log('Unsaved changes alert is hidden (via classList.add and style.display)');
            
            // Optional: Bootstrap close() can be used if the element
            // should be completely removed from the DOM after closing.
            // const alertInstance = bootstrap.Alert.getInstance(unsavedChangesAlert);
            // if (alertInstance) {
            //     alertInstance.close(); 
            // }
        }
        hasUnsavedChanges = false;
    }
    // --- End Global Definitions ---

    // --- NEW: Global Function for Checkbox Toggle ---
    function handleCheckboxToggle(checkbox) {
        const row = checkbox.closest('tr');
        const targetSelector = checkbox.getAttribute('data-target-input');
        if (row && targetSelector) {
            const targetInput = row.querySelector(targetSelector);
            if (targetInput) {
                targetInput.disabled = !checkbox.checked;
            }
        }
    }
    // --- End Global Function Checkbox Toggle ---

    document.addEventListener('DOMContentLoaded', function() {
        console.log("=== PAGE LOAD DEBUG ===");
        
        // Check if language and timezone fields exist
        const languageField = document.getElementById('language');
        const timezoneField = document.getElementById('timezone');
        
        console.log("Language field found:", !!languageField);
        if (languageField) {
            console.log("Language field value:", languageField.value);
            console.log("Language field name:", languageField.name);
            console.log("Language field classes:", languageField.className);
            console.log("Language field data-immediate-effect:", languageField.getAttribute('data-immediate-effect'));
        }
        
        console.log("Timezone field found:", !!timezoneField);
        if (timezoneField) {
            console.log("Timezone field value:", timezoneField.value);
            console.log("Timezone field name:", timezoneField.name);
            console.log("Timezone field classes:", timezoneField.className);
            console.log("Timezone field data-immediate-effect:", timezoneField.getAttribute('data-immediate-effect'));
        }
        
        // Check form
        configForm = document.getElementById('config-form');
        console.log("Config form found:", !!configForm);
        
        // Check unsaved changes alert
        unsavedChangesAlert = document.getElementById('unsaved-changes-alert');
        console.log("Unsaved changes alert found:", !!unsavedChangesAlert);
        
        console.log("=== END PAGE LOAD DEBUG ===");
        
        // Tooltip initialization
        initializeTooltips(document.body); // Initializes all tooltips on the page

        // --- Assignment of elements for Unsaved Changes (here, as DOM is ready) ---
        // CRITICAL: Assign to global variables, don't redeclare with const/let
        unsavedChangesAlert = document.getElementById('unsaved-changes-alert');
        restartRequiredAlert = document.getElementById('restart-required-alert'); // Assign here
        configForm = document.getElementById('config-form');
        
        // Ensure that alerts are hidden when the page loads
        if (unsavedChangesAlert) {
            unsavedChangesAlert.classList.add('force-hide');
            unsavedChangesAlert.style.display = 'none';
            hasUnsavedChanges = false;
        }
        if (restartRequiredAlert) {
            restartRequiredAlert.classList.add('force-hide');
            restartRequiredAlert.style.display = 'none';
            restartRequired = false;
        }
        
        // Mark that the page has been fully loaded
        document.body.setAttribute('data-page-loaded', 'true');
        
        // Register event for the first user click in the document
        document.addEventListener('click', function() {
            userHasInteracted = true;
        }, {once: true});
        
        // Event listeners for Floating-Save and Floating-Discard buttons
        const floatingSaveButton = document.getElementById('floating-save-button');
        if (floatingSaveButton) {
            floatingSaveButton.addEventListener('click', function() {
                saveConfigAjax();  // Call existing save function
            });
        }
        
        const floatingDiscardButton = document.getElementById('floating-discard-button');
        if (floatingDiscardButton) {
            floatingDiscardButton.addEventListener('click', function() {
                if (confirm('Are you sure you want to discard all changes?')) {
                    window.location.reload();  // Reload page
                }
            });
        }
        
        // CRITICAL FIX: Add event listener for main save button!
        const mainSaveButton = document.getElementById('save-config-button');
        if (mainSaveButton) {
            console.log("Adding event listener to main save button");
            mainSaveButton.addEventListener('click', function() {
                console.log("Main save button clicked!");
                saveConfigAjax();  // Call existing save function
            });
        } else {
            console.error("Main save button not found!");
        }
        // --- End Assignment ---

        // Event listener for changes in the form (now using global functions)
        if (configForm) {
            // For the basic settings that require a restart (tokens, bot settings, etc.)
            const criticalElements = configForm.querySelectorAll('.requires-restart');
            console.log(`Found ${criticalElements.length} elements with .requires-restart class`);
            
            criticalElements.forEach(element => {
                console.log(`Adding event listeners to: ${element.name || element.id} (${element.tagName})`);
                
                element.addEventListener('input', () => {
                    console.log(`INPUT event on ${element.name || element.id}: ${element.value}`);
                    if (userHasInteracted && document.body.getAttribute('data-page-loaded') === 'true') {
                        // Check if this element has immediate effect
                        const hasImmediateEffect = element.getAttribute('data-immediate-effect') === 'true';
                        console.log(`Has immediate effect: ${hasImmediateEffect}`);
                        showUnsavedChangesAlert(!hasImmediateEffect); // No restart required if immediate effect
                        if (hasImmediateEffect) {
                            console.log(`${element.name || element.id} changed - immediate effect, no restart required`);
                        }
                    }
                });
                element.addEventListener('change', () => {
                    console.log(`CHANGE event on ${element.name || element.id}: ${element.value}`);
                    if (userHasInteracted && document.body.getAttribute('data-page-loaded') === 'true') {
                        // Check if this element has immediate effect
                        const hasImmediateEffect = element.getAttribute('data-immediate-effect') === 'true';
                        console.log(`Has immediate effect: ${hasImmediateEffect}`);
                        showUnsavedChangesAlert(!hasImmediateEffect); // No restart required if immediate effect
                        if (hasImmediateEffect) {
                            console.log(`${element.name || element.id} changed - immediate effect, no restart required`);
                        }
                    }
                });
            });

            // For all other form elements
            configForm.addEventListener('input', (e) => {
                // Only display if user interaction has occurred and page is fully loaded
                if (!userHasInteracted || document.body.getAttribute('data-page-loaded') !== 'true') {
                    return;
                }
                
                // Exclude task management elements from triggering unsaved changes
                if (e.target.id === 'taskFilterStatus' || e.target.closest('#taskListBody') || e.target.closest('.task-filters')) {
                    return;
                }
                
                // Check if the element does not belong to the "requires-restart" class
                if (!e.target.closest('.requires-restart')) {
                    showUnsavedChangesAlert(false);
                }
            });
            
            configForm.addEventListener('change', (e) => {
                // Only display if user interaction has occurred and page is fully loaded
                if (!userHasInteracted || document.body.getAttribute('data-page-loaded') !== 'true') {
                    return;
                }
                
                // Exclude task management elements from triggering unsaved changes
                if (e.target.id === 'taskFilterStatus' || e.target.closest('#taskListBody') || e.target.closest('.task-filters')) {
                    return;
                }
                
                // Check if the element does not belong to the "requires-restart" class
                if (!e.target.closest('.requires-restart')) {
                    showUnsavedChangesAlert(false);
                }
            });
            
            configForm.addEventListener('click', (event) => {
                // Only display if user interaction has occurred and page is fully loaded
                if (!userHasInteracted || document.body.getAttribute('data-page-loaded') !== 'true') {
                    return;
                }
                
                // Exclude task management elements from triggering unsaved changes
                if (event.target.id === 'refreshTasksBtn' || 
                    event.target.closest('#taskListBody') || 
                    event.target.closest('.task-filters') ||
                    event.target.closest('.editTaskBtn') ||
                    event.target.closest('.deleteTaskBtn') ||
                    event.target.closest('.toggle-active')) {
                    return;
                }
                
                const target = event.target.closest('.remove-channel-btn, #add-channel-btn, .move-up-btn, .move-down-btn');
                if (target) {
                    // Check if the clicked element requires a restart
                    const requiresRestart = target.classList.contains('requires-restart');
                    showUnsavedChangesAlert(requiresRestart);
                }
            });
        }

        // Automatically hide messages
        setTimeout(function() {
            let flashMessages = document.querySelectorAll('.alert-dismissible');
            flashMessages.forEach(function(message) {
                let closeBtn = message.querySelector('.btn-close');
                if (closeBtn) {
                    closeBtn.click();
                }
            });
        }, 10000); // 10 seconds

        // All checkboxes with 'data-toggle-target' event listener (e.g., for Heartbeat Section)
        document.querySelectorAll('input[data-toggle-target]').forEach(function(checkbox) {
            const targetId = checkbox.getAttribute('data-toggle-target');
            const targetElement = document.getElementById(targetId);
            if(targetElement) {
                // Event listener for changes
                checkbox.addEventListener('change', function() {
                    targetElement.style.display = this.checked ? 'block' : 'none';
                });
                // Set initial state
                 targetElement.style.display = checkbox.checked ? 'block' : 'none';
            }
        });

        // --- Command Permissions Table Logic ---
        const permissionsTableBody = document.getElementById('command-permissions-table')?.querySelector('tbody');

        if (permissionsTableBody) { // Only execute if the table exists
            // Event listener for "Add Channel" Button
            const addChannelBtn = document.getElementById('add-channel-btn');
            if (addChannelBtn) {
                addChannelBtn.addEventListener('click', function() {
                    // Safer method for finding index
                    let maxIndex = 0;
                    permissionsTableBody.querySelectorAll('tr').forEach(row => {
                        const match = row.id.match(/channel-row-(\d+)/);
                        if (match && match[1]) {
                            maxIndex = Math.max(maxIndex, parseInt(match[1], 10));
                        }
                    });
                    const newIndex = maxIndex + 1;

                    const newRow = createEmptyChannelRow(newIndex); // Use external helper function
                    permissionsTableBody.appendChild(newRow);
                    initializeTooltips(newRow); // Initialize tooltips for new row
                    addExclusivityListeners(newRow); // <<< NEW: Add exclusivity listener for new row
                });
            }

            // Event listener for delete buttons (delegated to tbody)
            permissionsTableBody.addEventListener('click', function(event) {
                if (event.target.closest('.remove-channel-btn')) {
                    removeChannelRow(event); // Use external helper function
                }
            });

            // <<< NEW: Add event listener for existing rows on load
            permissionsTableBody.querySelectorAll('tr').forEach(row => {
                addExclusivityListeners(row);
            });

            // Event listener for clicks on Auto Refresh / Recreate checkboxes (delegation)
            permissionsTableBody.addEventListener('change', function(event) {
                if (event.target.classList.contains('auto-refresh-checkbox') || event.target.classList.contains('recreate-checkbox')) {
                     handleCheckboxToggle(event.target);
                     showUnsavedChangesAlert(false); // Trigger unsaved changes - no restart required
                }
            });

            // Set initial status for all rows
            permissionsTableBody.querySelectorAll('.auto-refresh-checkbox, .recreate-checkbox').forEach(checkbox => {
                 handleCheckboxToggle(checkbox);
             });
        }

        // --- Log Update --- 
        const logContentElement = document.getElementById('logContent');
        const refreshLogsBtn = document.getElementById('refreshLogsBtn');
        const actionLogContentElement = document.getElementById('actionLogContent');
        const refreshActionLogBtn = document.getElementById('refreshActionLogBtn');
        const downloadActionLogBtn = document.getElementById('downloadActionLogBtn'); // Link, not a direct button
        const clearActionLogBtn = document.getElementById('clearActionLogBtn');
        
        let logIntervalId = null;
        let currentLogLevel = 'info'; // Default log level
        let rawLogsCache = ''; // Cache for the full logs
        let minimalLogsCache = []; // New cache specifically for important log events
        const MAX_MINIMAL_LOGS = 500; // Maximum number of minimal log entries to store
        
        // Rate-limiting variables
        let lastLogFetch = 0; // Timestamp of the last request
        let lastActionLogFetch = 0;
        const MIN_FETCH_INTERVAL = 15000; // Minimum interval between requests in ms (15 seconds - optimized for better UX)
        let fetchInProgress = false; // Flag to prevent parallel requests
        let actionLogFetchInProgress = false;

        function isMinimalLogEntry(line) {
            // Define "important success messages" patterns here
            const successPatterns = [
                /Container .* started successfully/i,
                /Configuration saved successfully/i,
                // Add more patterns for important success messages if needed
            ];
            
            return line.includes('DDC is ready.') ||
                   successPatterns.some(pattern => pattern.test(line)) ||
                   (line.includes('Action received') && !line.includes('toggle_details'));
        }

        function updateMinimalLogsCache(logs) {
            const lines = logs.split('\n');
            
            // Find new minimal log entries and add them to the cache
            lines.forEach(line => {
                if (isMinimalLogEntry(line) && !minimalLogsCache.includes(line)) {
                    minimalLogsCache.push(line);
                    
                    // Limit cache to maximum size
                    if (minimalLogsCache.length > MAX_MINIMAL_LOGS) {
                        minimalLogsCache.shift(); // Remove the oldest entry
                    }
                }
            });
        }

        function filterLogs(logs, level) {
            const lines = logs.split('\n');
            if (level === 'debug') {
                return logs; // Show all lines
            }
            if (level === 'info') {
                // Show INFO, WARNING, ERROR, CRITICAL, and Action Received (excluding toggle)
                return lines.filter(line => 
                    line.includes(' INFO ') || 
                    line.includes(' WARNING ') || 
                    line.includes(' ERROR ') || 
                    line.includes(' CRITICAL ') || 
                    (line.includes('Action received') && !line.includes('toggle_details'))
                ).join('\n');
            }
            if (level === 'minimal') {
                // For minimal logs show the complete minimal logs cache
                // instead of just the entries that are currently in the log lines
                return minimalLogsCache.join('\n');
            }
            return logs; // Default to showing all if level is unknown
        }

        function displayFilteredLogs() {
            if (!logContentElement) return;
            const filteredLogsText = filterLogs(rawLogsCache, currentLogLevel);
            const lines = filteredLogsText.split('\n');

            const htmlLines = lines.map(line => {
                // Escape HTML entities first
                let processedLine = line.replace(/</g, "&lt;").replace(/>/g, "&gt;");

                // Define keywords and classes - Order matters for replacement priority
                const highlights = [
                    { class: 'log-error', keywords: ['error', 'critical', 'failed'] },
                    { class: 'log-warning', keywords: ['warning'] },
                    { class: 'log-success', keywords: ['success', 'successfully', 'started', 'completed', 'ready'] },
                    { class: 'log-debug', keywords: ['debug'] }
                    // INFO is not specifically highlighted, it's the default
                ];

                highlights.forEach(hl => {
                    // Build regex for all keywords in this class: \b(word1|word2|...)\b
                    const regex = new RegExp(`\\b(${hl.keywords.join('|')})\\b`, 'gi'); 
                    // Replace matched keywords, preserving original case ($1)
                    processedLine = processedLine.replace(regex, `<span class="${hl.class}">$1</span>`);
                });

                // Return the line with potentially multiple highlighted words
                return processedLine;
            });

            // Use innerHTML to render the spans
            logContentElement.innerHTML = htmlLines.join('\n');
            logContentElement.scrollTop = logContentElement.scrollHeight; // Scroll to bottom
        }

        // Container log retrieval function
        async function fetchContainerLogs() {
            if (!logContentElement) return false;
            
            // Rate-limiting: Check if enough time has passed since the last request
            const now = Date.now();
            if (now - lastLogFetch < MIN_FETCH_INTERVAL || fetchInProgress) {
                console.log('Skipping log fetch: Rate limit or fetch in progress');
                return false;
            }
            
            fetchInProgress = true;
            lastLogFetch = now;
            
            if (refreshLogsBtn) refreshLogsBtn.disabled = true;
            
            try {
                const response = await fetch("{{ url_for('log_bp.get_logs') }}");
                if (response.ok) {
                    rawLogsCache = await response.text(); // Store full logs
                    updateMinimalLogsCache(rawLogsCache); // Update the minimal logs cache
                    displayFilteredLogs(); // Display filtered logs
                    return true;
                } else if (response.status === 429) {
                    console.warn('Too many log requests, will retry later');
                    // For 429, don't overwrite the cache, just silently skip without showing a warning
                    // The existing content remains displayed
                } else {
                    rawLogsCache = `Error loading logs: ${response.statusText}`;
                    logContentElement.textContent = rawLogsCache; // Show error directly
                }
            } catch (error) {
                console.error("Error fetching logs:", error);
                rawLogsCache = `Error loading logs: ${error.message}`;
                logContentElement.textContent = rawLogsCache; // Show error directly
            } finally {
                fetchInProgress = false;
                if (refreshLogsBtn) {
                    setTimeout(() => {
                        refreshLogsBtn.disabled = false;
                    }, MIN_FETCH_INTERVAL);
                }
            }
            return false;
        }

        // OPTIMIZED Action log retrieval with better error handling
        async function fetchActionLogs() {
            if (!actionLogContentElement) return false;
            
            // Rate-limiting: Check if enough time has passed since the last request
            const now = Date.now();
            if (now - lastActionLogFetch < MIN_FETCH_INTERVAL || actionLogFetchInProgress) {
                console.log('Skipping action log fetch: Rate limit or fetch in progress');
                return false;
            }
            
            actionLogFetchInProgress = true;
            lastActionLogFetch = now;
            
            // TIMEOUT PROTECTION: If loading takes too long, show a better message
            const timeoutId = setTimeout(() => {
                if (actionLogContentElement.textContent === 'Loading action log...') {
                    actionLogContentElement.textContent = 'Action log is taking longer than expected to load...';
                }
            }, 10000); // 10 second timeout
            
            if (refreshActionLogBtn) refreshActionLogBtn.disabled = true;
            
            try {
                const response = await fetch("{{ url_for('action_log_bp.get_action_log') }}");
                if (response.ok) {
                    clearTimeout(timeoutId); // Clear timeout on success
                    const logs = await response.text();
                    actionLogContentElement.textContent = logs;
                    return true;
                } else if (response.status === 429) {
                    console.warn('Rate limit hit for action logs - will retry in 30 seconds');
                    // SMART RETRY: Schedule retry after 30 seconds instead of showing permanent error
                    if (actionLogContentElement.textContent === '[Loading action log...]') {
                        actionLogContentElement.textContent = 'Rate limit reached. Retrying in 30 seconds...';
                    }
                    setTimeout(() => {
                        console.log('Retrying action log fetch after rate limit cooldown');
                        fetchActionLogs();
                    }, 30000); // Retry after 30 seconds
                } else {
                    actionLogContentElement.textContent = `Error loading action logs: ${response.statusText}`;
                }
            } catch (error) {
                console.error("Error fetching action logs:", error);
                actionLogContentElement.textContent = `Error loading action logs: ${error.message}`;
            } finally {
                clearTimeout(timeoutId); // Always clear timeout in finally block
                actionLogFetchInProgress = false;
                if (refreshActionLogBtn) {
                    setTimeout(() => {
                        refreshActionLogBtn.disabled = false;
                    }, MIN_FETCH_INTERVAL);
                }
            }
            return false;
        }

        // OPTIMIZED: Staggered log fetching to prevent rate limits
        async function fetchAllLogs() {
            console.log('Starting staggered log fetch to avoid rate limits');
            
            // Fetch container logs first
            const containerLogResult = await fetchContainerLogs();
            
            // Wait 2 seconds before fetching action logs to prevent rate limiting
            setTimeout(async () => {
                await fetchActionLogs();
                console.log('Staggered logs update completed');
            }, 2000); // 2 second delay between requests
            
            console.log('Container logs fetched, action logs queued');
        }

        // --- Log Level Button Listeners ---
        const logLevelRadios = document.querySelectorAll('input[name="logLevel"]');
        logLevelRadios.forEach(radio => {
            radio.addEventListener('change', (event) => {
                currentLogLevel = event.target.value;
                console.log('Log level changed to:', currentLogLevel); // Debug log
                displayFilteredLogs(); // Update display with new filter
            });
        });
        // --- End Log Level Button Listeners ---

        // --- Scheduler Debug Mode Listener ---
        const schedulerDebugCheckbox = document.getElementById('schedulerDebugMode');
        if (schedulerDebugCheckbox) {
            schedulerDebugCheckbox.addEventListener('change', function() {
                showUnsavedChangesAlert(false); // Simple change, doesn't require restart
                
                // Information popup about setting change
                let message = this.checked ? 
                    "Scheduler Debug Mode enabled. Save configuration to activate detailed logging." : 
                    "Scheduler Debug Mode disabled. Save configuration to reduce log verbosity.";
                
                // Create temporary notification
                const notification = document.createElement('div');
                notification.classList.add('toast', 'align-items-center', 'text-white', 'bg-info', 'border-0');
                notification.setAttribute('role', 'alert');
                notification.setAttribute('aria-live', 'assertive');
                notification.setAttribute('aria-atomic', 'true');
                notification.style.position = 'fixed';
                notification.style.bottom = '20px';
                notification.style.right = '20px';
                notification.style.zIndex = '9999';
                
                notification.innerHTML = `
                    <div class="d-flex">
                        <div class="toast-body">
                            ${message}
                        </div>
                        <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                    </div>
                `;
                
                document.body.appendChild(notification);
                
                // Show and auto-hide the notification
                const toast = new bootstrap.Toast(notification, { delay: 5000 });
                toast.show();
                
                // Remove from DOM after hiding
                notification.addEventListener('hidden.bs.toast', function() {
                    document.body.removeChild(notification);
                });
            });
        }
        // --- End Scheduler Debug Mode Listener ---

        if (refreshLogsBtn) {
            refreshLogsBtn.addEventListener('click', fetchContainerLogs);
        }
        
        if (refreshActionLogBtn) {
            refreshActionLogBtn.addEventListener('click', fetchActionLogs);
        }

        if (clearActionLogBtn) {
             clearActionLogBtn.addEventListener('click', async () => {
                 if (confirm("Are you sure you want to permanently clear the user action log? This cannot be undone.")) {
                    clearActionLogBtn.disabled = true;
                    try {
                        const response = await fetch("{{ url_for('action_log_bp.clear_action_log') }}", {
                             method: 'POST',
                             headers: { 'X-Requested-With': 'XMLHttpRequest' } // In case CSRF or similar becomes relevant
                         });
                        const data = await response.json();
                        if (response.ok && data.success) {
                             alert(data.message || 'Action log cleared.');
                             fetchActionLogs(); // Reload the log (now showing only the CLEAR message)
                        } else {
                             alert('Error clearing action log: ' + (data.message || 'Unknown error'));
                        }
                    } catch (error) {
                         console.error("Error clearing action log:", error);
                         alert('Failed to clear action log: ' + error.message);
                    } finally {
                        clearActionLogBtn.disabled = false;
                    }
                 }
             });
         }

        // OPTIMIZED: Load action logs immediately, then start staggered auto-refresh
        fetchActionLogs(); // Load action logs first to clear "Loading..." quickly
        setTimeout(fetchContainerLogs, 1000); // Load container logs after 1 second
        
        // A common interval for both logs
        if (logIntervalId) clearInterval(logIntervalId);
        logIntervalId = setInterval(fetchAllLogs, 120000); // RATE-LIMIT OPTIMIZED: Updates logs every 2 minutes with staggered fetching
        // --- END: Log Update ---

        // --- Temporary Debug Mode Setup ---
        const enableButton = document.getElementById('enableTempDebugBtn');
        if (enableButton) {
            enableButton.addEventListener('click', enableTempDebug);
        }
        
        // Initial check of temp debug status
        refreshTempDebugStatus();
        // --- END: Temporary Debug Mode Setup ---

        // --- Server Selection Table Logic ---
        const serverTableBody = document.getElementById('docker-container-list');

        if (serverTableBody) {
            // Event listener for changes to the "Active" checkboxes
            serverTableBody.addEventListener('change', function(event) {
                if (event.target.classList.contains('server-checkbox')) {
                    const row = event.target.closest('tr');
                    if (row) {
                        const isActive = event.target.checked;
                        const elementsToToggle = row.querySelectorAll('.action-checkbox, .display-name-input');
                        elementsToToggle.forEach(el => {
                            el.disabled = !isActive;
                        });
                        updateOrderNumbers(serverTableBody); // <<< Update numbering here
                        showUnsavedChangesAlert(true); // Server selection requires restart
                    }
                }
            });

            // Optional: Logic for "Select All" checkbox (if needed/desired)
            const selectAllCheckbox = document.getElementById('select-all-servers');
            if (selectAllCheckbox) {
                selectAllCheckbox.addEventListener('change', function() {
                    const allServerCheckboxes = serverTableBody.querySelectorAll('.server-checkbox');
                    allServerCheckboxes.forEach(checkbox => {
                        if (checkbox.checked !== selectAllCheckbox.checked) {
                            checkbox.checked = selectAllCheckbox.checked;
                            // Manually trigger the change event to activate the row logic
                            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                    });
                });
            }
        }
        // --- END: Server Selection Table Logic ---

        // --- Server Table Sorting Logic ---
        if (serverTableBody) { 
            function updateSortButtonStates(tbody) {
                const rows = tbody.querySelectorAll('tr');
                rows.forEach((row, index) => {
                    const upBtn = row.querySelector('.move-up-btn'); // Button for "Move up" (+)
                    const downBtn = row.querySelector('.move-down-btn'); // Button for "Move down" (-)
                    if (upBtn) upBtn.disabled = (index === 0);
                    if (downBtn) downBtn.disabled = (index === rows.length - 1);
                });
            }

            // Revised helper function for updating numbers (only for active items)
            function updateOrderNumbers(tbody) {
                 const rows = tbody.querySelectorAll('tr[data-container-name]'); 
                 let activeCounter = 1; // Counter only for active items
                 rows.forEach((row) => {
                     const numSpan = row.querySelector('.order-number');
                     const isActiveCheckbox = row.querySelector('.server-checkbox');
                     
                     if (numSpan && isActiveCheckbox) {
                        if (isActiveCheckbox.checked) {
                             numSpan.textContent = activeCounter;
                             numSpan.style.visibility = 'visible';
                             activeCounter++;
                        } else {
                             numSpan.textContent = ''; // Empty for inactive items
                             numSpan.style.visibility = 'hidden'; // Hidden
                        }
                     } 
                 });
             }

            // Event Listener for clicks on Up/Down buttons (delegation)
            serverTableBody.addEventListener('click', function(event) {
                const upButton = event.target.closest('.move-up-btn');
                const downButton = event.target.closest('.move-down-btn');

                if (upButton) {
                    const currentRow = upButton.closest('tr');
                    const previousRow = currentRow.previousElementSibling;
                    if (previousRow) {
                        serverTableBody.insertBefore(currentRow, previousRow);
                        updateSortButtonStates(serverTableBody);
                        updateOrderNumbers(serverTableBody); // Update numbers
                        showUnsavedChangesAlert(true); // Order change requires restart
                    }
                }

                if (downButton) {
                    const currentRow = downButton.closest('tr');
                    const nextRow = currentRow.nextElementSibling;
                    if (nextRow) {
                        serverTableBody.insertBefore(nextRow, currentRow);
                        updateSortButtonStates(serverTableBody);
                        updateOrderNumbers(serverTableBody); // Update numbers
                        showUnsavedChangesAlert(true); // Order change requires restart
                    }
                }
            });

            // Set initial button status and numbers
            updateSortButtonStates(serverTableBody);
            updateOrderNumbers(serverTableBody); // Set initial numbering
        }
        // --- END: Server Table Sorting ---

        // --- Docker Container Refresh Button ---
        const refreshDockerButton = document.getElementById('refresh-docker-list');
        if (refreshDockerButton) {
            refreshDockerButton.addEventListener('click', function() {
                const button = this;
                const icon = button.querySelector('i');
                const statusText = document.getElementById('cache-status-text');
                
                // Show loading state
                button.disabled = true;
                if (icon) {
                    icon.classList.add('bi-arrow-repeat-spin'); // Add spinning animation class
                }
                if (statusText) {
                    statusText.textContent = 'Refreshing container list...';
                    statusText.style.display = 'block';
                }
                
                // Make request to refresh containers
                fetch("{{ url_for('main_bp.refresh_containers') }}", {
                    method: 'POST',
                    headers: { 'X-Requested-With': 'XMLHttpRequest' }
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Show success message briefly before reload
                        if (statusText) {
                            statusText.textContent = `Success! Found ${data.container_count} containers. Reloading...`;
                        }
                        // Reload the page after a short delay to show the success message
                        setTimeout(() => {
                            window.location.reload();
                        }, 1000);
                    } else {
                        // Show error message
                        if (statusText) {
                            statusText.textContent = 'Error: ' + (data.message || 'Failed to refresh container list');
                        }
                        // Re-enable button after error
                        button.disabled = false;
                        if (icon) {
                            icon.classList.remove('bi-arrow-repeat-spin');
                        }
                        // Hide error message after 5 seconds
                        setTimeout(() => {
                            if (statusText) {
                                statusText.style.display = 'none';
                            }
                        }, 5000);
                    }
                })
                .catch(error => {
                    console.error('Error refreshing containers:', error);
                    if (statusText) {
                        statusText.textContent = 'Error: Could not connect to server';
                    }
                    // Re-enable button after error
                    button.disabled = false;
                    if (icon) {
                        icon.classList.remove('bi-arrow-repeat-spin');
                    }
                    // Hide error message after 5 seconds
                    setTimeout(() => {
                        if (statusText) {
                            statusText.style.display = 'none';
                        }
                    }, 5000);
                });
            });
        }
        // --- END: Docker Container Refresh Button ---

        // --- MANUAL FIX: Add event listeners for language and timezone fields ---
        const languageFieldForEvents = document.getElementById('language');
        const timezoneFieldForEvents = document.getElementById('timezone');
        
        if (languageFieldForEvents) {
            console.log("Adding manual event listeners to language field");
            
            // Set userHasInteracted when field gets focus
            languageFieldForEvents.addEventListener('focus', () => {
                console.log("Language field focused - setting userHasInteracted = true");
                userHasInteracted = true;
            });
            
            // Add both input and change event listeners
            languageFieldForEvents.addEventListener('input', () => {
                console.log("Language field INPUT event triggered");
                console.log("  userHasInteracted:", userHasInteracted);
                console.log("  page loaded:", document.body.getAttribute('data-page-loaded'));
                
                // Always show alert for language changes
                if (document.body.getAttribute('data-page-loaded') === 'true') {
                    userHasInteracted = true; // Ensure it's set
                    showUnsavedChangesAlert(false); // immediate effect, no restart required
                }
            });
            
            languageFieldForEvents.addEventListener('change', () => {
                console.log("Language field CHANGE event triggered");
                console.log("  userHasInteracted:", userHasInteracted);
                console.log("  page loaded:", document.body.getAttribute('data-page-loaded'));
                
                // Always show alert for language changes
                if (document.body.getAttribute('data-page-loaded') === 'true') {
                    userHasInteracted = true; // Ensure it's set
                    showUnsavedChangesAlert(false); // immediate effect, no restart required
                }
            });
        }
        
        if (timezoneFieldForEvents) {
            console.log("Adding manual event listeners to timezone field");
            
            // Set userHasInteracted when field gets focus
            timezoneFieldForEvents.addEventListener('focus', () => {
                console.log("Timezone field focused - setting userHasInteracted = true");
                userHasInteracted = true;
            });
            
            timezoneFieldForEvents.addEventListener('input', () => {
                console.log("Timezone field INPUT event triggered");
                console.log("  userHasInteracted:", userHasInteracted);
                console.log("  page loaded:", document.body.getAttribute('data-page-loaded'));
                
                // Always show alert for timezone changes
                if (document.body.getAttribute('data-page-loaded') === 'true') {
                    userHasInteracted = true; // Ensure it's set
                    showUnsavedChangesAlert(false); // immediate effect, no restart required
                }
            });
            
            timezoneFieldForEvents.addEventListener('change', () => {
                console.log("Timezone field CHANGE event triggered");
                console.log("  userHasInteracted:", userHasInteracted);
                console.log("  page loaded:", document.body.getAttribute('data-page-loaded'));
                
                // Always show alert for timezone changes
                if (document.body.getAttribute('data-page-loaded') === 'true') {
                    userHasInteracted = true; // Ensure it's set
                    showUnsavedChangesAlert(false); // immediate effect, no restart required
                }
            });
        }
        // --- END MANUAL FIX ---

    }); // End document.addEventListener('DOMContentLoaded', ...)

    // --- Helper Functions (Defined outside DOMContentLoaded) ---

    // Function to remove a channel row
    function removeChannelRow(event) {
        const button = event.target.closest('.remove-channel-btn');
         if (!button) return;

        const rowId = button.dataset.rowId;
        const rowToRemove = document.getElementById(rowId);
        if (rowToRemove) {
            const tableBody = document.getElementById('command-permissions-table')?.querySelector('tbody');
            // Check if tableBody exists and if there is more than one row
            if (tableBody && tableBody.querySelectorAll('tr').length > 1) {
                 rowToRemove.remove();
             } else {
                 alert('Cannot delete the last channel row.');
             }
        }
    }

    // Helper to create an empty row 
    function createEmptyChannelRow(index) {
        const tr = document.createElement('tr');
        tr.id = `channel-row-${index}`;
        const defaultUpdateInterval = 5;
        const defaultInactivityTimeout = 10; 
        const defaultEnableRefresh = true;
        const defaultRecreate = true;

        // Correct string construction without template literals in HTML
        tr.innerHTML = `
            <td>
                <input type="text" class="form-control form-control-sm" name="channel_name_${index}" placeholder="Channel Name">
            </td>
            <td>
                <input type="text" class="form-control form-control-sm" name="channel_id_${index}" placeholder="Channel ID" id="channel_id_${index}">
                 <input type="hidden" name="old_channel_id_${index}" value="">
            </td>
            <td class="text-center"><div class="form-check"><input class="form-check-input cmd-serverstatus" type="checkbox" name="cmd_serverstatus_${index}" value="1"><label class="form-check-label visually-hidden">/status</label></div></td>
            <td class="text-center"><div class="form-check"><input class="form-check-input" type="checkbox" name="cmd_command_${index}" value="1"><label class="form-check-label visually-hidden">/command</label></div></td>
            <td class="text-center"><div class="form-check"><input class="form-check-input cmd-control" type="checkbox" name="cmd_control_${index}" value="1"><label class="form-check-label visually-hidden">/control</label></div></td>
            <td class="text-center"><div class="form-check"><input class="form-check-input" type="checkbox" name="cmd_schedule_${index}" value="1"><label class="form-check-label visually-hidden">/task</label></div></td>
            <td class="text-center border-start border-secondary-subtle"><div class="form-check"><input class="form-check-input" type="checkbox" name="post_initial_${index}" value="1" ${defaultRecreate ? 'checked' : ''}><label class="form-check-label visually-hidden">Initial</label></div></td>
            <td class="text-center"><div class="form-check"><input class="form-check-input auto-refresh-checkbox" type="checkbox" name="enable_auto_refresh_${index}" value="1" ${defaultEnableRefresh ? 'checked' : ''} data-target-input=".interval-minutes-input"><label class="form-check-label visually-hidden">Refresh</label></div></td>
            <td><input type="number" class="form-control form-control-sm interval-minutes-input" name="update_interval_minutes_${index}" value="${defaultUpdateInterval}" min="1" style="width: 60px; margin: auto;" ${!defaultEnableRefresh ? 'disabled' : ''}></td>
            <td class="text-center"><div class="form-check"><input class="form-check-input recreate-checkbox" type="checkbox" name="recreate_messages_on_inactivity_${index}" value="1" ${defaultRecreate ? 'checked' : ''} data-target-input=".inactivity-minutes-input"><label class="form-check-label visually-hidden">Recreate</label></div></td>
            <td><input type="number" class="form-control form-control-sm inactivity-minutes-input" name="inactivity_timeout_minutes_${index}" value="${defaultInactivityTimeout}" min="1" style="width: 60px; margin: auto;" ${!defaultRecreate ? 'disabled' : ''}></td>
            <td class="text-center">
                <button type="button" class="btn btn-sm btn-danger remove-channel-btn" data-row-id="channel-row-${index}">
                    <i class="bi bi-trash"></i>
                </button>
            </td>
        `;
        // Add listeners to the new row
        addExclusivityListeners(tr);
        handleCheckboxToggle(tr.querySelector('.auto-refresh-checkbox')); 
        handleCheckboxToggle(tr.querySelector('.recreate-checkbox'));     
        return tr;
    }

    // Helper to initialize tooltips
    function initializeTooltips(parentElement) {
        const tooltipTriggerList = parentElement.querySelectorAll('[data-bs-toggle="tooltip"]');
        tooltipTriggerList.forEach(function (tooltipTriggerEl) {
             // Remove existing tooltip if necessary to avoid duplicates
             const existingTooltip = bootstrap.Tooltip.getInstance(tooltipTriggerEl);
             if (existingTooltip) {
                 existingTooltip.dispose();
             }
             // Create new tooltip
             new bootstrap.Tooltip(tooltipTriggerEl, {
                 html: true,
                 boundary: document.body, // Prevents cutting off
                 trigger: 'hover focus' // Show on hover and focus
             });
         });
    }

    // <<< NEW: Function to enforce command exclusivity >>>
    function enforceCommandExclusivity(changedCheckbox) {
        const row = changedCheckbox.closest('tr');
        if (!row) return;

        // Use classes for easier selection
        const controlCheckbox = row.querySelector('.cmd-control');
        const serverStatusCheckbox = row.querySelector('.cmd-serverstatus');

        if (!controlCheckbox || !serverStatusCheckbox) return;

        // If the changed checkbox is the Control checkbox
        if (changedCheckbox === controlCheckbox) {
            if (controlCheckbox.checked) {
                // Control activated -> Deactivate ServerStatus (and uncheck)
                if (serverStatusCheckbox.checked) {
                    serverStatusCheckbox.checked = false;
                }
                serverStatusCheckbox.disabled = true;
                controlCheckbox.disabled = false; // Ensure this checkbox remains active
            } else {
                 // Control deactivated -> Reactivate ServerStatus
                 serverStatusCheckbox.disabled = false;
            }
        }
        // If the changed checkbox is the ServerStatus checkbox
        else if (changedCheckbox === serverStatusCheckbox) {
            if (serverStatusCheckbox.checked) {
                 // ServerStatus activated -> Deactivate Control (and uncheck)
                 if (controlCheckbox.checked) {
                     controlCheckbox.checked = false;
                 }
                 controlCheckbox.disabled = true;
                 serverStatusCheckbox.disabled = false; // Ensure this checkbox remains active
            } else {
                 // ServerStatus deactivated -> Reactivate Control
                 controlCheckbox.disabled = false;
            }
        }
    }

    // <<< NEW: Function to add event listeners for exclusivity >>>
    function addExclusivityListeners(row) {
        const controlCheckbox = row.querySelector('.cmd-control');
        const serverStatusCheckbox = row.querySelector('.cmd-serverstatus');

        if (controlCheckbox) {
            controlCheckbox.addEventListener('change', function() {
                enforceCommandExclusivity(this);
            });
            // Initial check on add/load
             if (controlCheckbox.checked) {
                 enforceCommandExclusivity(controlCheckbox);
             }
        }
        if (serverStatusCheckbox) {
            serverStatusCheckbox.addEventListener('change', function() {
                enforceCommandExclusivity(this);
            });
             // Initial check on add/load (only if control wasn't already checked)
             if (serverStatusCheckbox.checked && !(controlCheckbox && controlCheckbox.checked)) {
                 enforceCommandExclusivity(serverStatusCheckbox);
             }
        }
    }

    // AJAX save function
    function saveConfigAjax() {
        const form = document.getElementById('config-form');
        const saveButton = document.getElementById('save-config-button');
        const notification = document.getElementById('save-notification');
        if (!form || !saveButton || !notification) {
            console.error("Missing elements:", { form: !!form, saveButton: !!saveButton, notification: !!notification });
            return; // Cancel function
        }
        const originalButtonHtml = saveButton.innerHTML;
        
        console.log("=== SAVE CONFIG DEBUG START ===");
        
        // Check language and timezone fields specifically
        const languageField = document.getElementById('language');
        const timezoneField = document.getElementById('timezone');
        console.log("Language field:", languageField ? languageField.value : "NOT FOUND");
        console.log("Timezone field:", timezoneField ? timezoneField.value : "NOT FOUND");
        
        // Create FormData and manually add all form elements
        console.log("Creating FormData manually...");
        const formData = new FormData();
        
        // First add all normal form fields
        const formElements = form.querySelectorAll('input, select, textarea');
        console.log(`Found ${formElements.length} form elements`);
        
        formElements.forEach(element => {
            // Skip checkboxes with name="selected_servers", which we handle separately
            if (element.name === 'selected_servers') {
                return;
            }
            
            // Debug output for language and timezone fields
            if (element.name === 'language' || element.name === 'timezone') {
                console.log(`Processing ${element.name}: ${element.value}`);
            }
            
            // Special debug for language field
            if (element.id === 'language' || element.name === 'language') {
                console.log(`LANGUAGE FIELD DEBUG:`);
                console.log(`  ID: ${element.id}`);
                console.log(`  Name: ${element.name}`);
                console.log(`  Value: ${element.value}`);
                console.log(`  Type: ${element.type}`);
                console.log(`  TagName: ${element.tagName}`);
            }
            
            // For checkboxes, only set the value if they are checked
            if (element.type === 'checkbox') {
                formData.set(element.name, element.checked ? (element.value || "1") : "0");
            }
            // For radio buttons, only set if checked
            else if (element.type === 'radio') {
                if (element.checked) {
                    formData.set(element.name, element.value);
                }
            }
            // For normal fields, simply use the value
            else if (element.name) {
                formData.set(element.name, element.value);
                // Extra debug for language/timezone
                if (element.name === 'language' || element.name === 'timezone') {
                    console.log(`ADDED TO FORMDATA: ${element.name} = ${element.value}`);
                }
            }
        });
        
        console.log("=== MANUAL TEST END ===");
        
        // --- NEW: Capture server configuration --- 
        const serverTableBody = document.getElementById('docker-container-list');
        const orderedServerNames = [];
        const selectedServerNames = [];
        
        // MANUAL FIX: Add language and timezone fields manually if they're not in the form
        const languageFieldReal = document.getElementById('language');
        const timezoneFieldReal = document.getElementById('timezone');
        
        if (languageFieldReal) {
            console.log(`MANUAL ADD (REAL): Adding language field: ${languageFieldReal.value}`);
            formData.set('language', languageFieldReal.value);
        }
        
        if (timezoneFieldReal) {
            console.log(`MANUAL ADD (REAL): Adding timezone field: ${timezoneFieldReal.value}`);
            formData.set('timezone', timezoneFieldReal.value);
        }
        
        if (serverTableBody) {
            console.log("Server table found, processing server configuration...");
            
            // First phase: First collect all activated containers in the correct order
            const activeRows = [];
            const inactiveRows = [];
            
            // Sort rows into active and inactive
            serverTableBody.querySelectorAll('tr[data-container-name]').forEach((row) => {
                const checkbox = row.querySelector('.server-checkbox');
                if (checkbox && checkbox.checked) {
                    activeRows.push(row);
                } else {
                    inactiveRows.push(row);
                }
            });
            
            // Sort active rows by their numbering
            activeRows.sort((a, b) => {
                const numA = a.querySelector('.order-number')?.textContent || "999";
                const numB = b.querySelector('.order-number')?.textContent || "999";
                return parseInt(numA) - parseInt(numB);
            });
            
            // First collect all active containers in order
            activeRows.forEach((row) => {
                const containerName = row.getAttribute('data-container-name');
                if (!containerName) return;
                
                orderedServerNames.push(containerName);
                selectedServerNames.push(containerName);
                console.log(`Active container #${orderedServerNames.length}: ${containerName}`);
                
                // Collect actions
                const actions = [];
                
                // Status action
                const statusCheckbox = row.querySelector('input[name="allow_status_' + containerName + '"]');
                if (statusCheckbox) {
                    console.log(`[DEBUG] ${containerName} Status checkbox found: checked=${statusCheckbox.checked}`);
                    if (statusCheckbox.checked) {
                        actions.push("status");
                        formData.append('allow_status_' + containerName, '1');
                        console.log(`[DEBUG] ${containerName} Status: ALLOWED (sending '1')`);
                    } else {
                        // CRITICAL: Also send '0' for unchecked boxes
                        formData.append('allow_status_' + containerName, '0');
                        console.log(`[DEBUG] ${containerName} Status: DENIED (sending '0')`);
                    }
                } else {
                    console.log(`[DEBUG] ${containerName} Status checkbox NOT FOUND`);
                }
                
                // Start action
                const startCheckbox = row.querySelector('input[name="allow_start_' + containerName + '"]');
                if (startCheckbox) {
                    console.log(`[DEBUG] ${containerName} Start checkbox found: checked=${startCheckbox.checked}`);
                    if (startCheckbox.checked) {
                        actions.push("start");
                        formData.append('allow_start_' + containerName, '1');
                        console.log(`[DEBUG] ${containerName} Start: ALLOWED (sending '1')`);
                    } else {
                        // CRITICAL: Also send '0' for unchecked boxes
                        formData.append('allow_start_' + containerName, '0');
                        console.log(`[DEBUG] ${containerName} Start: DENIED (sending '0')`);
                    }
                } else {
                    console.log(`[DEBUG] ${containerName} Start checkbox NOT FOUND`);
                }
                
                // Stop action
                const stopCheckbox = row.querySelector('input[name="allow_stop_' + containerName + '"]');
                if (stopCheckbox) {
                    console.log(`[DEBUG] ${containerName} Stop checkbox found: checked=${stopCheckbox.checked}`);
                    if (stopCheckbox.checked) {
                        actions.push("stop");
                        formData.append('allow_stop_' + containerName, '1');
                        console.log(`[DEBUG] ${containerName} Stop: ALLOWED (sending '1')`);
                    } else {
                        // CRITICAL: Also send '0' for unchecked boxes
                        formData.append('allow_stop_' + containerName, '0');
                        console.log(`[DEBUG] ${containerName} Stop: DENIED (sending '0')`);
                    }
                } else {
                    console.log(`[DEBUG] ${containerName} Stop checkbox NOT FOUND`);
                }
                
                // Restart action
                const restartCheckbox = row.querySelector('input[name="allow_restart_' + containerName + '"]');
                if (restartCheckbox) {
                    console.log(`[DEBUG] ${containerName} Restart checkbox found: checked=${restartCheckbox.checked}`);
                    if (restartCheckbox.checked) {
                        actions.push("restart");
                        formData.append('allow_restart_' + containerName, '1');
                        console.log(`[DEBUG] ${containerName} Restart: ALLOWED (sending '1')`);
                    } else {
                        // CRITICAL: Also send '0' for unchecked boxes
                        formData.append('allow_restart_' + containerName, '0');
                        console.log(`[DEBUG] ${containerName} Restart: DENIED (sending '0')`);
                    }
                } else {
                    console.log(`[DEBUG] ${containerName} Restart checkbox NOT FOUND`);
                }
                
                console.log(`Container '${containerName}' allowed actions: ${actions.join(', ')}`);
                
                // Display Name
                const displayNameInput = row.querySelector('input[name="display_name_' + containerName + '"]');
                if (displayNameInput) {
                    formData.append('display_name_' + containerName, displayNameInput.value || containerName);
                }
            });
            
            // Then add inactive containers
            inactiveRows.forEach((row) => {
                const containerName = row.getAttribute('data-container-name');
                if (!containerName) return;
                
                orderedServerNames.push(containerName);
                console.log(`Inactive container added: ${containerName}`);
            });
            
            // Ordered list as string
            formData.append('server_order', orderedServerNames.join('__,__'));
            console.log(`Server order: ${orderedServerNames.join(', ')}`);
            
            // Selected servers
            selectedServerNames.forEach(serverName => {
                formData.append('selected_servers', serverName);
            });
            console.log(`Selected servers (${selectedServerNames.length}): ${selectedServerNames.join(', ')}`);
        } else {
            console.error("Server table not found!");
        }
        
        // --- NEW: Capture channel configuration ---
        console.log("Processing channel configuration...");
        const channelTable = document.getElementById('command-permissions-table');
        if (channelTable) {
            const channelRows = channelTable.querySelectorAll('tbody tr');
            console.log(`Found ${channelRows.length} channel rows`);
            
            channelRows.forEach((row, index) => {
                const rowIndex = index + 1; // 1-based indexing
                
                // Channel Name
                const channelNameInput = row.querySelector(`input[name="channel_name_${rowIndex}"]`);
                if (channelNameInput) {
                    formData.set(`channel_name_${rowIndex}`, channelNameInput.value || '');
                    console.log(`Channel ${rowIndex} name: ${channelNameInput.value}`);
                }
                
                // Channel ID
                const channelIdInput = row.querySelector(`input[name="channel_id_${rowIndex}"]`);
                if (channelIdInput) {
                    formData.set(`channel_id_${rowIndex}`, channelIdInput.value || '');
                    console.log(`Channel ${rowIndex} ID: ${channelIdInput.value}`);
                }
                
                // Command permissions
                ['serverstatus', 'command', 'control', 'schedule'].forEach(cmd => {
                    const cmdCheckbox = row.querySelector(`input[name="cmd_${cmd}_${rowIndex}"]`);
                    if (cmdCheckbox) {
                        formData.set(`cmd_${cmd}_${rowIndex}`, cmdCheckbox.checked ? '1' : '0');
                        console.log(`Channel ${rowIndex} cmd_${cmd}: ${cmdCheckbox.checked ? '1' : '0'}`);
                    }
                });
                
                // Other channel settings
                const settingsMap = {
                    'post_initial': 'post_initial',
                    'enable_auto_refresh': 'enable_auto_refresh', 
                    'recreate_messages_on_inactivity': 'recreate_messages_on_inactivity'
                };
                
                Object.entries(settingsMap).forEach(([setting, formName]) => {
                    const checkbox = row.querySelector(`input[name="${formName}_${rowIndex}"]`);
                    if (checkbox) {
                        formData.set(`${formName}_${rowIndex}`, checkbox.checked ? '1' : '0');
                        console.log(`Channel ${rowIndex} ${formName}: ${checkbox.checked ? '1' : '0'}`);
                    }
                });
                
                // Numeric settings
                const numericSettings = ['update_interval_minutes', 'inactivity_timeout_minutes'];
                numericSettings.forEach(setting => {
                    const input = row.querySelector(`input[name="${setting}_${rowIndex}"]`);
                    if (input) {
                        formData.set(`${setting}_${rowIndex}`, input.value || '1');
                        console.log(`Channel ${rowIndex} ${setting}: ${input.value}`);
                    }
                });
            });
        } else {
            console.log("Channel permissions table not found");
        }
        
        // Add information about split configuration files
        formData.append('config_split_enabled', '1');

        // Hide unsaved changes alert when starting to save
        hideUnsavedChangesAlert();

        // Visual feedback
        saveButton.disabled = true;
        saveButton.innerHTML = `<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Saving...`;
        notification.style.display = 'none';
        
        // Output of all FormData values in console for debugging purposes
        console.log("FormData content before sending:");
        for (let [key, value] of formData.entries()) {
            console.log(`${key}: ${value}`);
        }

        fetch("{{ url_for('main_bp.save_config_api') }}", {
            method: 'POST',
            body: formData,
            headers: { 'X-Requested-With': 'XMLHttpRequest' }
        })
        .then(response => { 
            if (!response.ok) {
                 return response.json()
                     .then(errData => {
                         const message = errData.message || errData.error || `HTTP error ${response.status}`;
                         throw new Error(message);
                      })
                     .catch((jsonParseError) => {
                         throw new Error(`HTTP error ${response.status}`);
                      });
             }
            return response.json();
         })
        .then(data => {
             if (data.success) {
                 notification.textContent = data.message || 'Configuration saved successfully!';
                 notification.className = 'alert alert-success';
                 notification.style.display = 'block';
                 hideUnsavedChangesAlert();
                 hasUnsavedChanges = false; // Reset flag
                 
                 // Show special message if critical settings changed
                 if (data.critical_settings_changed) {
                     const criticalMessage = document.createElement('div');
                     criticalMessage.className = 'small mt-2 text-success';
                     criticalMessage.innerHTML = '<i class="bi bi-check-circle"></i> <strong>Critical settings updated:</strong> Language/timezone changes are now active without restart!';
                     notification.appendChild(criticalMessage);
                 }
                 
                 // Show restart message only if necessary and if changes 
                 // were actually made to critical elements
                 if (restartRequired) {
                     if (document.querySelectorAll('.requires-restart').length > 0) {
                         // Check if changes were actually made to a critical element
                         let changesDetected = false;
                         document.querySelectorAll('.requires-restart').forEach(element => {
                             // For checkboxes: The original setting was changed by saving
                             if (element.type === 'checkbox' && element.checked) {
                                 changesDetected = true;
                             }
                             // For input fields: If not empty, there was a change
                             else if (element.value && element.value.trim() !== '') {
                                 changesDetected = true;
                             }
                         });
                         
                         if (changesDetected) {
                             showRestartRequiredAlert();
                         }
                     }
                     
                     restartRequired = false; // Reset after successful saving
                 }
                 
                 // Display new information about split configuration
                 if (data.config_files && data.config_files.length > 0) {
                     const configList = document.createElement('div');
                     configList.className = 'small mt-2';
                     configList.innerHTML = 'Saved configuration files: ' + 
                         data.config_files.map(file => `<code>${file}</code>`).join(', ');
                     notification.appendChild(configList);
                 }
             } else {
                 throw new Error(data.message || 'An unknown error occurred while saving.');
             }
         })
         .catch(error => {
             notification.textContent = `Error: ${error.message}`;
             notification.className = 'alert alert-danger';
             notification.style.display = 'block';
         })
         .finally(() => {
            if (saveButton) { 
                 saveButton.disabled = false;
                 saveButton.innerHTML = originalButtonHtml; // Restore original button text
             } else {
                 console.error("Save button element was not found in .finally()!");
             }
             setTimeout(() => {
                  if (notification && notification.style.display !== 'none') { // Additional check for notification
                      notification.style.display = 'none';
                  }
              }, 7000); // 7 seconds
         });
    }

    // Function to show/hide Channel ID based on method (No longer needed)
    /* function toggleChannelId() {
        const methodSelect = document.getElementById('heartbeat_method');
        const channelIdGroup = document.getElementById('heartbeat-channel-id-group'); // Assuming this ID exists for the div/group

        if (methodSelect && channelIdGroup) {
            if (methodSelect.value === 'channel') {
                channelIdGroup.style.display = ''; // Show the group
            } else {
                channelIdGroup.style.display = 'none'; // Hide the group
            }
        }
    } */

    // --- Temporary Debug Mode Functions ---
    
    // Timer for refreshing the temporary debug status
    let tempDebugStatusTimer = null;
    
    // Function to refresh the temporary debug status
    function refreshTempDebugStatus() {
        fetch("{{ url_for('main_bp.temp_debug_status') }}", {
            method: 'GET',
            headers: { 'X-Requested-With': 'XMLHttpRequest' }
        })
        .then(response => response.json())
        .then(data => {
            const statusElement = document.getElementById('tempDebugStatus');
            const enableButton = document.getElementById('enableTempDebugBtn');
            
            if (data.success) {
                if (data.is_enabled) {
                    // Debug is active
                    statusElement.innerHTML = `
                        <span class="text-warning">
                            <i class="bi bi-stopwatch"></i> 
                            Debug active for ${data.remaining_formatted} 
                            (expires at ${data.expiry_formatted})
                        </span>
                        <button type="button" id="disableTempDebugBtn" class="btn btn-sm btn-link text-danger p-0 ms-2">
                            <i class="bi bi-x-circle"></i> Disable
                        </button>
                    `;
                    enableButton.disabled = true;
                    
                    // Add event listener to the disable button
                    const disableButton = document.getElementById('disableTempDebugBtn');
                    if (disableButton) {
                        disableButton.addEventListener('click', disableTempDebug);
                    }
                    
                    // Continue polling if debug is active
                    if (tempDebugStatusTimer) clearTimeout(tempDebugStatusTimer);
                    tempDebugStatusTimer = setTimeout(refreshTempDebugStatus, 5000); // Check every 5 seconds
                } else {
                    // Debug is inactive
                    statusElement.innerHTML = `<span class="text-muted">Temporary debug mode is inactive</span>`;
                    enableButton.disabled = false;
                    
                    // Stop polling if debug is inactive
                    if (tempDebugStatusTimer) {
                        clearTimeout(tempDebugStatusTimer);
                        tempDebugStatusTimer = null;
                    }
                }
            } else {
                // Error occurred
                statusElement.innerHTML = `<span class="text-danger">Error: ${data.message}</span>`;
                enableButton.disabled = false;
            }
        })
        .catch(error => {
            console.error("Error fetching temp debug status:", error);
            const statusElement = document.getElementById('tempDebugStatus');
            statusElement.innerHTML = `<span class="text-danger">Error checking status</span>`;
            
            // Stop polling on error
            if (tempDebugStatusTimer) {
                clearTimeout(tempDebugStatusTimer);
                tempDebugStatusTimer = null;
            }
        });
    }
    
    // Function to enable temporary debug mode
    function enableTempDebug() {
        const durationSelect = document.getElementById('tempDebugDuration');
        const duration = durationSelect ? durationSelect.value : '10';
        const statusElement = document.getElementById('tempDebugStatus');
        
        statusElement.innerHTML = `<span class="text-info"><i class="bi bi-hourglass-split"></i> Enabling temporary debug mode...</span>`;
        
        const formData = new FormData();
        formData.append('duration', duration);
        
        fetch("{{ url_for('main_bp.enable_temp_debug') }}", {
            method: 'POST',
            body: formData,
            headers: { 'X-Requested-With': 'XMLHttpRequest' }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Show success notification
                const notification = document.getElementById('save-notification');
                if (notification) {
                    notification.className = 'alert alert-warning';
                    notification.textContent = data.message;
                    notification.style.display = 'block';
                    setTimeout(() => { notification.style.display = 'none'; }, 5000);
                }
                
                // Refresh the status display
                refreshTempDebugStatus();
            } else {
                statusElement.innerHTML = `<span class="text-danger">Error: ${data.message}</span>`;
            }
        })
        .catch(error => {
            console.error("Error enabling temp debug:", error);
            statusElement.innerHTML = `<span class="text-danger">Error enabling temporary debug mode</span>`;
        });
    }
    
    // Function to disable temporary debug mode
    function disableTempDebug() {
        const statusElement = document.getElementById('tempDebugStatus');
        statusElement.innerHTML = `<span class="text-info"><i class="bi bi-hourglass-split"></i> Disabling temporary debug mode...</span>`;
        
        fetch("{{ url_for('main_bp.disable_temp_debug') }}", {
            method: 'POST',
            headers: { 'X-Requested-With': 'XMLHttpRequest' }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Show success notification
                const notification = document.getElementById('save-notification');
                if (notification) {
                    notification.className = 'alert alert-info';
                    notification.textContent = data.message;
                    notification.style.display = 'block';
                    setTimeout(() => { notification.style.display = 'none'; }, 5000);
                }
                
                // Refresh the status display
                refreshTempDebugStatus();
            } else {
                statusElement.innerHTML = `<span class="text-danger">Error: ${data.message}</span>`;
            }
        })
        .catch(error => {
            console.error("Error disabling temp debug:", error);
            statusElement.innerHTML = `<span class="text-danger">Error disabling temporary debug mode</span>`;
        });
    }
    
    // Test function that can be called manually from browser console
    window.testLanguageSave = function() {
        console.log("=== MANUAL TEST START ===");
        
        const form = document.getElementById('config-form');
        const languageField = document.getElementById('language');
        const timezoneField = document.getElementById('timezone');
        
        console.log("Form found:", !!form);
        console.log("Language field found:", !!languageField);
        console.log("Timezone field found:", !!timezoneField);
        
        // Extended debug: Check if language field is inside the form
        if (languageField && form) {
            console.log("Language field is inside form:", form.contains(languageField));
            console.log("Language field parent form:", languageField.form === form);
        }
        
        if (languageField) {
            console.log("Current language value:", languageField.value);
            console.log("Setting language to 'de'...");
            languageField.value = 'de';
            console.log("New language value:", languageField.value);
            
            // Trigger change event
            languageField.dispatchEvent(new Event('change', { bubbles: true }));
            console.log("Change event dispatched");
        }
        
        // Test form data collection using the SAME logic as saveConfigAjax
        if (form) {
            console.log("Creating FormData manually (same as saveConfigAjax)...");
            const formData = new FormData();
            
            // First add all normal form fields (EXACT same logic as saveConfigAjax)
            const formElements = form.querySelectorAll('input, select, textarea');
            console.log(`Found ${formElements.length} form elements`);
            
            // Count elements by type
            let inputCount = 0, selectCount = 0, textareaCount = 0;
            let languageFound = false, timezoneFound = false;
            
            formElements.forEach(element => {
                if (element.tagName === 'INPUT') inputCount++;
                if (element.tagName === 'SELECT') selectCount++;
                if (element.tagName === 'TEXTAREA') textareaCount++;
                
                if (element.name === 'language') languageFound = true;
                if (element.name === 'timezone') timezoneFound = true;
                
                // Skip checkboxes with name="selected_servers", which we handle separately
                if (element.name === 'selected_servers') {
                    return;
                }
                
                // Debug output for language and timezone fields
                if (element.name === 'language' || element.name === 'timezone') {
                    console.log(`Processing ${element.name}: ${element.value}`);
                }
                
                // Special debug for language field
                if (element.id === 'language' || element.name === 'language') {
                    console.log(`LANGUAGE FIELD DEBUG:`);
                    console.log(`  ID: ${element.id}`);
                    console.log(`  Name: ${element.name}`);
                    console.log(`  Value: ${element.value}`);
                    console.log(`  Type: ${element.type}`);
                    console.log(`  TagName: ${element.tagName}`);
                }
                
                // For checkboxes, only set the value if they are checked
                if (element.type === 'checkbox') {
                    formData.set(element.name, element.checked ? (element.value || "1") : "0");
                }
                // For radio buttons, only set if checked
                else if (element.type === 'radio') {
                    if (element.checked) {
                        formData.set(element.name, element.value);
                    }
                }
                // For normal fields, simply use the value
                else if (element.name) {
                    formData.set(element.name, element.value);
                    // Extra debug for language/timezone
                    if (element.name === 'language' || element.name === 'timezone') {
                        console.log(`ADDED TO FORMDATA: ${element.name} = ${element.value}`);
                    }
                }
            });
            
            console.log(`Element counts: INPUT=${inputCount}, SELECT=${selectCount}, TEXTAREA=${textareaCount}`);
            console.log(`Language found in form: ${languageFound}`);
            console.log(`Timezone found in form: ${timezoneFound}`);
            
            // MANUAL FIX: Add language and timezone fields manually if they're not in the form
            const languageField = document.getElementById('language');
            const timezoneField = document.getElementById('timezone');
            
            if (languageField && !languageFound) {
                console.log(`MANUAL ADD: Adding language field manually: ${languageField.value}`);
                formData.set('language', languageField.value);
            }
            
            if (timezoneField && !timezoneFound) {
                console.log(`MANUAL ADD: Adding timezone field manually: ${timezoneField.value}`);
                formData.set('timezone', timezoneField.value);
            }
            
            console.log("FormData entries:");
            let entryCount = 0;
            for (let [key, value] of formData.entries()) {
                if (key === 'language' || key === 'timezone' || entryCount < 10) {
                    console.log(`${key}: ${value}`);
                }
                entryCount++;
            }
            console.log(`Total entries: ${entryCount}`);
        }
        
        console.log("=== MANUAL TEST END ===");
    };
    
    // Direct save test function
    window.testDirectSave = function() {
        console.log("=== DIRECT SAVE TEST ===");
        
        // Set language to German first
        const languageField = document.getElementById('language');
        if (languageField) {
            console.log("Setting language to 'de'...");
            languageField.value = 'de';
        }
        
        // Call saveConfigAjax directly
        console.log("Calling saveConfigAjax()...");
        saveConfigAjax();
    };

    // Test event listeners
    window.testEventListeners = function() {
        console.log("=== EVENT LISTENER TEST ===");
        
        const languageField = document.getElementById('language');
        if (!languageField) {
            console.error("Language field not found!");
            return;
        }
        
        console.log("Language field found");
        console.log("Classes:", languageField.className);
        console.log("Has requires-restart class:", languageField.classList.contains('requires-restart'));
        console.log("data-immediate-effect:", languageField.getAttribute('data-immediate-effect'));
        
        // Check if event listeners are attached
        console.log("Triggering change event...");
        const oldValue = languageField.value;
        languageField.value = oldValue === 'en' ? 'de' : 'en';
        
        // Trigger both input and change events
        languageField.dispatchEvent(new Event('input', { bubbles: true }));
        languageField.dispatchEvent(new Event('change', { bubbles: true }));
        
        console.log("Events triggered. Check if unsaved changes alert appeared.");
        
        // Check alert state
        const unsavedAlert = document.getElementById('unsaved-changes-alert');
        if (unsavedAlert) {
            console.log("Unsaved changes alert exists");
            console.log("Alert visible:", !unsavedAlert.classList.contains('force-hide'));
            console.log("Alert display style:", unsavedAlert.style.display);
        } else {
            console.error("Unsaved changes alert element not found!");
        }
        
        console.log("=== END EVENT LISTENER TEST ===");
    };

    // Test save button functionality
    window.testSaveButton = function() {
        console.log("=== SAVE BUTTON TEST ===");
        
        const saveButton = document.getElementById('save-config-button');
        const floatingSaveButton = document.getElementById('floating-save-button');
        
        console.log("Main save button found:", !!saveButton);
        console.log("Floating save button found:", !!floatingSaveButton);
        
        if (saveButton) {
            console.log("Main save button:");
            console.log("  ID:", saveButton.id);
            console.log("  Type:", saveButton.type);
            console.log("  Disabled:", saveButton.disabled);
            console.log("  OnClick:", saveButton.onclick);
            
            // Check for event listeners
            const listeners = getEventListeners ? getEventListeners(saveButton) : "getEventListeners not available";
            console.log("  Event listeners:", listeners);
            
            // Try clicking it
            console.log("Clicking main save button...");
            saveButton.click();
        } else {
            console.error("Main save button not found!");
        }
        
        console.log("=== END SAVE BUTTON TEST ===");
    };

    // Comprehensive save button debug
    window.debugSaveButtons = function() {
        console.log("=== COMPREHENSIVE SAVE BUTTON DEBUG ===");
        
        // Find all save-related buttons
        const mainSaveButton = document.getElementById('save-config-button');
        const floatingSaveButton = document.getElementById('floating-save-button');
        const allButtons = document.querySelectorAll('button');
        
        console.log("Main save button:", mainSaveButton);
        console.log("Floating save button:", floatingSaveButton);
        console.log("Total buttons on page:", allButtons.length);
        
        // Check for buttons with save-related text
        allButtons.forEach(btn => {
            if (btn.textContent.toLowerCase().includes('save')) {
                console.log("Found save-related button:", {
                    id: btn.id,
                    text: btn.textContent,
                    type: btn.type,
                    disabled: btn.disabled,
                    onclick: btn.onclick,
                    parent: btn.parentElement?.tagName
                });
            }
        });
        
        // Check if saveConfigAjax function exists
        console.log("saveConfigAjax function exists:", typeof saveConfigAjax === 'function');
        
        // Try to directly call saveConfigAjax
        if (typeof saveConfigAjax === 'function') {
            console.log("Calling saveConfigAjax directly...");
            try {
                saveConfigAjax();
            } catch (e) {
                console.error("Error calling saveConfigAjax:", e);
            }
        }
        
        console.log("=== END DEBUG ===");
    };

    // Test language/timezone event listeners
    window.testLanguageEvents = function() {
        console.log("=== TESTING LANGUAGE/TIMEZONE EVENTS ===");
        
        const languageField = document.getElementById('language');
        const timezoneField = document.getElementById('timezone');
        const pageLoaded = document.body.getAttribute('data-page-loaded');
        
        console.log("Language field found:", !!languageField);
        console.log("Timezone field found:", !!timezoneField);
        console.log("userHasInteracted (global):", userHasInteracted);
        console.log("pageLoaded:", pageLoaded);
        
        // Force user interaction
        console.log("Forcing userHasInteracted = true");
        userHasInteracted = true;
        
        // Check if listeners are attached using browser dev tools
        if (languageField) {
            // Try to trigger events manually
            console.log("Triggering manual change on language field...");
            const oldValue = languageField.value;
            languageField.value = oldValue === 'en' ? 'de' : 'en';
            
            // Dispatch events
            languageField.dispatchEvent(new Event('input', { bubbles: true }));
            languageField.dispatchEvent(new Event('change', { bubbles: true }));
            
            // Check alert
            setTimeout(() => {
                const alert = document.getElementById('unsaved-changes-alert');
                console.log("Alert visible after language change:", alert && !alert.classList.contains('force-hide'));
                console.log("Alert display style:", alert ? alert.style.display : "alert not found");
                
                // Restore original value
                languageField.value = oldValue;
            }, 100);
        }
        
        console.log("=== END TEST ===");
    };
</script> 