{# --- JavaScript at the end --- #}
<script src="{{ url_for('static', filename='js/config-ui.js') }}"></script>
<script src="{{ url_for('static', filename='js/auto_actions.js') }}"></script>
<script>
    // --- Global variables and functions for Unsaved Changes (moved out of DOMContentLoaded) ---
    let hasUnsavedChanges = false;
    let unsavedChangesAlert = null; // Will be assigned in DOMContentLoaded
    let configForm = null;          // Will be assigned in DOMContentLoaded
    let userHasInteracted = false;  // CRITICAL: Make this global so all event listeners can access it

    // --- NEW: Variable and function for Restart Alert ---
    let restartRequiredAlert = null;
    let restartRequired = false;    // Flag whether restart is required
    
    function showRestartRequiredAlert() {
        if (!restartRequiredAlert) restartRequiredAlert = document.getElementById('restart-required-alert');
        if (restartRequiredAlert && restartRequired) {
            restartRequiredAlert.classList.remove('force-hide');
            console.log('Restart alert is displayed (via classList.remove)');
        }
    }
    // --- End Restart Alert --- 

    function showUnsavedChangesAlert(requiresRestart = false) {
        console.log(`showUnsavedChangesAlert called with requiresRestart: ${requiresRestart}`);
        
        // Ensures that the element was found
        if (!unsavedChangesAlert) unsavedChangesAlert = document.getElementById('unsaved-changes-alert');
        
        // Only display if not yet displayed and element exists
        if (unsavedChangesAlert && !hasUnsavedChanges) {
            unsavedChangesAlert.classList.remove('force-hide');
            unsavedChangesAlert.style.display = 'flex'; // CRITICAL: Also set display style!
            hasUnsavedChanges = true;
            console.log('Unsaved changes alert is displayed (via classList.remove and style.display)');
        } else {
            console.log(`Alert not shown - unsavedChangesAlert: ${!!unsavedChangesAlert}, hasUnsavedChanges: ${hasUnsavedChanges}`);
        }
        
        // Set the restart flag if required
        if (requiresRestart) {
            restartRequired = true;
            console.log('Restart flag set');
        }
    }

    function hideUnsavedChangesAlert() {
        // Ensures that the element was found
        if (!unsavedChangesAlert) unsavedChangesAlert = document.getElementById('unsaved-changes-alert');
        
        if (unsavedChangesAlert) {
            // Primarily add class to hide it
            unsavedChangesAlert.classList.add('force-hide'); 
            unsavedChangesAlert.style.display = 'none'; // Also set display style for consistency
            console.log('Unsaved changes alert is hidden (via classList.add and style.display)');
            
            // Optional: Bootstrap close() can be used if the element
            // should be completely removed from the DOM after closing.
            // const alertInstance = bootstrap.Alert.getInstance(unsavedChangesAlert);
            // if (alertInstance) {
            //     alertInstance.close(); 
            // }
        }
        hasUnsavedChanges = false;
    }
    // --- End Global Definitions ---

    // --- NEW: Global Function for Checkbox Toggle ---
    function handleCheckboxToggle(checkbox) {
        const row = checkbox.closest('tr');
        const targetSelector = checkbox.getAttribute('data-target-input');
        if (row && targetSelector) {
            const targetInput = row.querySelector(targetSelector);
            if (targetInput) {
                targetInput.disabled = !checkbox.checked;
            }
        }
    }
    // --- End Global Function Checkbox Toggle ---

    document.addEventListener('DOMContentLoaded', function() {
        console.log("=== PAGE LOAD DEBUG ===");
        
        // Check if language and timezone fields exist
        const languageField = document.getElementById('language');
        const timezoneField = document.getElementById('timezone');
        
        console.log("Language field found:", !!languageField);
        if (languageField) {
            console.log("Language field value:", languageField.value);
            console.log("Language field name:", languageField.name);
            console.log("Language field classes:", languageField.className);
            console.log("Language field data-immediate-effect:", languageField.getAttribute('data-immediate-effect'));
        }
        
        console.log("Timezone field found:", !!timezoneField);
        if (timezoneField) {
            console.log("Timezone field value:", timezoneField.value);
            console.log("Timezone field name:", timezoneField.name);
            console.log("Timezone field classes:", timezoneField.className);
            console.log("Timezone field data-immediate-effect:", timezoneField.getAttribute('data-immediate-effect'));
        }
        
        // Check form
        configForm = document.getElementById('config-form');
        console.log("Config form found:", !!configForm);
        
        // Check unsaved changes alert
        unsavedChangesAlert = document.getElementById('unsaved-changes-alert');
        console.log("Unsaved changes alert found:", !!unsavedChangesAlert);
        
        console.log("=== END PAGE LOAD DEBUG ===");
        
        // Tooltip initialization
        initializeTooltips(document.body); // Initializes all tooltips on the page

        // --- Assignment of elements for Unsaved Changes (here, as DOM is ready) ---
        // CRITICAL: Assign to global variables, don't redeclare with const/let
        unsavedChangesAlert = document.getElementById('unsaved-changes-alert');
        restartRequiredAlert = document.getElementById('restart-required-alert'); // Assign here
        configForm = document.getElementById('config-form');
        
        // Ensure that alerts are hidden when the page loads
        if (unsavedChangesAlert) {
            unsavedChangesAlert.classList.add('force-hide');
            unsavedChangesAlert.style.display = 'none';
            hasUnsavedChanges = false;
        }
        if (restartRequiredAlert) {
            restartRequiredAlert.classList.add('force-hide');
            restartRequiredAlert.style.display = 'none';
            restartRequired = false;
        }
        
        // Mark that the page has been fully loaded
        document.body.setAttribute('data-page-loaded', 'true');
        
        // Register event for the first user click in the document
        document.addEventListener('click', function() {
            userHasInteracted = true;
        }, {once: true});
        
        // Event listeners for Floating-Save and Floating-Discard buttons
        const floatingSaveButton = document.getElementById('floating-save-button');
        if (floatingSaveButton) {
            floatingSaveButton.addEventListener('click', function() {
                saveConfigAjax();  // Call existing save function
            });
        }
        
        const floatingDiscardButton = document.getElementById('floating-discard-button');
        if (floatingDiscardButton) {
            floatingDiscardButton.addEventListener('click', function() {
                if (confirm('Are you sure you want to discard all changes?')) {
                    window.location.reload();  // Reload page
                }
            });
        }
        
        // CRITICAL FIX: Add event listener for main save button!
        const mainSaveButton = document.getElementById('save-config-button');
        if (mainSaveButton) {
            console.log("Adding event listener to main save button");
            mainSaveButton.addEventListener('click', function() {
                console.log("Main save button clicked!");
                saveConfigAjax();  // Call existing save function
            });
        } else {
            console.error("Main save button not found!");
        }
        // --- End Assignment ---

        // Event listener for changes in the form (now using global functions)
        if (configForm) {
            // For the basic settings that require a restart (tokens, bot settings, etc.)
            const criticalElements = configForm.querySelectorAll('.requires-restart');
            console.log(`Found ${criticalElements.length} elements with .requires-restart class`);
            
            criticalElements.forEach(element => {
                console.log(`Adding event listeners to: ${element.name || element.id} (${element.tagName})`);
                
                element.addEventListener('input', () => {
                    console.log(`INPUT event on ${element.name || element.id}: ${element.value}`);
                    if (userHasInteracted && document.body.getAttribute('data-page-loaded') === 'true') {
                        // Check if this element has immediate effect
                        const hasImmediateEffect = element.getAttribute('data-immediate-effect') === 'true';
                        console.log(`Has immediate effect: ${hasImmediateEffect}`);
                        showUnsavedChangesAlert(!hasImmediateEffect); // No restart required if immediate effect
                        if (hasImmediateEffect) {
                            console.log(`${element.name || element.id} changed - immediate effect, no restart required`);
                        }
                    }
                });
                element.addEventListener('change', () => {
                    console.log(`CHANGE event on ${element.name || element.id}: ${element.value}`);
                    if (userHasInteracted && document.body.getAttribute('data-page-loaded') === 'true') {
                        // Check if this element has immediate effect
                        const hasImmediateEffect = element.getAttribute('data-immediate-effect') === 'true';
                        console.log(`Has immediate effect: ${hasImmediateEffect}`);
                        showUnsavedChangesAlert(!hasImmediateEffect); // No restart required if immediate effect
                        if (hasImmediateEffect) {
                            console.log(`${element.name || element.id} changed - immediate effect, no restart required`);
                        }
                    }
                });
            });

            // For all other form elements
            configForm.addEventListener('input', (e) => {
                // Only display if user interaction has occurred and page is fully loaded
                if (!userHasInteracted || document.body.getAttribute('data-page-loaded') !== 'true') {
                    return;
                }
                
                // Exclude task management elements from triggering unsaved changes
                if (e.target.id === 'taskFilterStatus' || e.target.closest('#taskListBody') || e.target.closest('.task-filters')) {
                    return;
                }
                
                // Check if the element does not belong to the "requires-restart" class
                if (!e.target.closest('.requires-restart')) {
                    showUnsavedChangesAlert(false);
                }
            });
            
            configForm.addEventListener('change', (e) => {
                // Only display if user interaction has occurred and page is fully loaded
                if (!userHasInteracted || document.body.getAttribute('data-page-loaded') !== 'true') {
                    return;
                }
                
                // Exclude task management elements from triggering unsaved changes
                if (e.target.id === 'taskFilterStatus' || e.target.closest('#taskListBody') || e.target.closest('.task-filters')) {
                    return;
                }
                
                // Check if the element does not belong to the "requires-restart" class
                if (!e.target.closest('.requires-restart')) {
                    showUnsavedChangesAlert(false);
                }
            });
            
            configForm.addEventListener('click', (event) => {
                // Only display if user interaction has occurred and page is fully loaded
                if (!userHasInteracted || document.body.getAttribute('data-page-loaded') !== 'true') {
                    return;
                }
                
                // Exclude task management elements from triggering unsaved changes
                if (event.target.id === 'refreshTasksBtn' || 
                    event.target.closest('#taskListBody') || 
                    event.target.closest('.task-filters') ||
                    event.target.closest('.editTaskBtn') ||
                    event.target.closest('.deleteTaskBtn') ||
                    event.target.closest('.toggle-active')) {
                    return;
                }
                
                const target = event.target.closest('.remove-channel-btn, #add-channel-btn, .move-up-btn, .move-down-btn');
                if (target) {
                    // Check if the clicked element requires a restart
                    const requiresRestart = target.classList.contains('requires-restart');
                    showUnsavedChangesAlert(requiresRestart);
                }
            });
        }

        // Automatically hide messages
        setTimeout(function() {
            let flashMessages = document.querySelectorAll('.alert-dismissible');
            flashMessages.forEach(function(message) {
                let closeBtn = message.querySelector('.btn-close');
                if (closeBtn) {
                    closeBtn.click();
                }
            });
        }, 10000); // 10 seconds

        // All checkboxes with 'data-toggle-target' event listener (e.g., for Heartbeat Section)
        document.querySelectorAll('input[data-toggle-target]').forEach(function(checkbox) {
            const targetId = checkbox.getAttribute('data-toggle-target');
            const targetElement = document.getElementById(targetId);
            if(targetElement) {
                // Event listener for changes
                checkbox.addEventListener('change', function() {
                    targetElement.style.display = this.checked ? 'block' : 'none';
                });
                // Set initial state
                 targetElement.style.display = checkbox.checked ? 'block' : 'none';
            }
        });

        // --- Command Permissions Table Logic ---
        const permissionsTableBody = document.getElementById('command-permissions-table')?.querySelector('tbody');

        if (permissionsTableBody) { // Only execute if the table exists
            // Event listener for "Add Channel" Button
            const addChannelBtn = document.getElementById('add-channel-btn');
            if (addChannelBtn) {
                addChannelBtn.addEventListener('click', function() {
                    // Safer method for finding index
                    let maxIndex = 0;
                    permissionsTableBody.querySelectorAll('tr').forEach(row => {
                        const match = row.id.match(/channel-row-(\d+)/);
                        if (match && match[1]) {
                            maxIndex = Math.max(maxIndex, parseInt(match[1], 10));
                        }
                    });
                    const newIndex = maxIndex + 1;

                    const newRow = createEmptyChannelRow(newIndex); // Use external helper function
                    permissionsTableBody.appendChild(newRow);
                    initializeTooltips(newRow); // Initialize tooltips for new row
                    addExclusivityListeners(newRow); // <<< NEW: Add exclusivity listener for new row
                });
            }

            // Event listener for delete buttons (delegated to tbody)
            permissionsTableBody.addEventListener('click', function(event) {
                if (event.target.closest('.remove-channel-btn')) {
                    removeChannelRow(event); // Use external helper function
                }
            });

            // <<< NEW: Add event listener for existing rows on load
            permissionsTableBody.querySelectorAll('tr').forEach(row => {
                addExclusivityListeners(row);
            });

            // Event listener for clicks on Auto Refresh / Recreate checkboxes (delegation)
            permissionsTableBody.addEventListener('change', function(event) {
                if (event.target.classList.contains('auto-refresh-checkbox') || event.target.classList.contains('recreate-checkbox')) {
                     handleCheckboxToggle(event.target);
                     showUnsavedChangesAlert(false); // Trigger unsaved changes - no restart required
                }
            });

            // Set initial status for all rows
            permissionsTableBody.querySelectorAll('.auto-refresh-checkbox, .recreate-checkbox').forEach(checkbox => {
                 handleCheckboxToggle(checkbox);
             });
        }

        // --- Log Update --- 
        const logContentElement = document.getElementById('logContent');
        const refreshLogsBtn = document.getElementById('refreshLogsBtn');
        // Action log elements removed (now integrated into main log system)
        
        let logIntervalId = null;
        let currentLogLevel = 'info'; // Default log level
        let rawLogsCache = ''; // Cache for the full logs
        let minimalLogsCache = []; // New cache specifically for important log events
        const MAX_MINIMAL_LOGS = 500; // Maximum number of minimal log entries to store
        
        // Smart scroll tracking
        let userScrolledUp = false;
        let wasAtBottom = true;
        
        // Rate-limiting variables
        let lastLogFetch = 0; // Timestamp of the last request
        let lastActionLogFetch = 0;
        const MIN_FETCH_INTERVAL = 15000; // Minimum interval between requests in ms (15 seconds - optimized for better UX)
        let fetchInProgress = false; // Flag to prevent parallel requests
        let actionLogFetchInProgress = false;

        function isMinimalLogEntry(line) {
            // Define "important success messages" patterns here
            const successPatterns = [
                /Container .* started successfully/i,
                /Configuration saved successfully/i,
                // Add more patterns for important success messages if needed
            ];
            
            return line.includes('DDC is ready.') ||
                   successPatterns.some(pattern => pattern.test(line)) ||
                   (line.includes('Action received') && !line.includes('toggle_details'));
        }

        function updateMinimalLogsCache(logs) {
            const lines = logs.split('\n');
            
            // Find new minimal log entries and add them to the cache
            lines.forEach(line => {
                if (isMinimalLogEntry(line) && !minimalLogsCache.includes(line)) {
                    minimalLogsCache.push(line);
                    
                    // Limit cache to maximum size
                    if (minimalLogsCache.length > MAX_MINIMAL_LOGS) {
                        minimalLogsCache.shift(); // Remove the oldest entry
                    }
                }
            });
        }

        function filterLogs(logs, level) {
            const lines = logs.split('\n');
            if (level === 'debug') {
                return logs; // Show all lines
            }
            if (level === 'info') {
                // Show INFO, WARNING, ERROR, CRITICAL, and Action Received (excluding toggle)
                return lines.filter(line => 
                    line.includes(' INFO ') || 
                    line.includes(' WARNING ') || 
                    line.includes(' ERROR ') || 
                    line.includes(' CRITICAL ') || 
                    (line.includes('Action received') && !line.includes('toggle_details'))
                ).join('\n');
            }
            if (level === 'minimal') {
                // For minimal logs show the complete minimal logs cache
                // instead of just the entries that are currently in the log lines
                return minimalLogsCache.join('\n');
            }
            return logs; // Default to showing all if level is unknown
        }

        function displayFilteredLogs() {
            if (!logContentElement) return;
            const filteredLogsText = filterLogs(rawLogsCache, currentLogLevel);
            const lines = filteredLogsText.split('\n');

            const htmlLines = lines.map(line => {
                // Escape HTML entities first
                let processedLine = line.replace(/</g, "&lt;").replace(/>/g, "&gt;");

                // Define keywords and classes - Order matters for replacement priority
                const highlights = [
                    { class: 'log-error', keywords: ['error', 'critical', 'failed'] },
                    { class: 'log-warning', keywords: ['warning'] },
                    { class: 'log-success', keywords: ['success', 'successfully', 'started', 'completed', 'ready'] },
                    { class: 'log-debug', keywords: ['debug'] }
                    // INFO is not specifically highlighted, it's the default
                ];

                highlights.forEach(hl => {
                    // Build regex for all keywords in this class: \b(word1|word2|...)\b
                    const regex = new RegExp(`\\b(${hl.keywords.join('|')})\\b`, 'gi'); 
                    // Replace matched keywords, preserving original case ($1)
                    processedLine = processedLine.replace(regex, `<span class="${hl.class}">$1</span>`);
                });

                // Return the line with potentially multiple highlighted words
                return processedLine;
            });

            // Use innerHTML to render the spans
            logContentElement.innerHTML = htmlLines.join('\n');
            
            // Smart scroll: only auto-scroll if user was at bottom
            if (wasAtBottom && !userScrolledUp) {
                logContentElement.scrollTop = logContentElement.scrollHeight;
            }
        }

        // Container log retrieval function (updated to work with new system)
        async function fetchContainerLogs() {
            // Now just calls the new fetchLogsByType function  
            return await fetchLogsByType(window.currentLogType || 'container');
        }

        // fetchActionLogs function removed (now integrated into main log system)

        // Simplified log fetching (action logs now integrated)
        async function fetchAllLogs() {
            console.log('Fetching logs...');
            await fetchContainerLogs();
            console.log('Logs fetched');
        }

        // --- Log Level Button Listeners removed (filters no longer used) ---
        // --- End Log Level Button Listeners ---

        // --- Debug Level Toggle Listener ---
        const debugLevelCheckbox = document.getElementById('debugLevelToggle');
        if (debugLevelCheckbox) {
            debugLevelCheckbox.addEventListener('change', function() {
                showUnsavedChangesAlert(false); // Simple change, doesn't require restart
                
                // Information popup about setting change
                let message = this.checked ? 
                    "Debug Level enabled. Save configuration to activate detailed logging." : 
                    "Debug Level disabled. Save configuration to switch to Info level logging.";
                
                // Create temporary notification
                const notification = document.createElement('div');
                notification.classList.add('toast', 'align-items-center', 'text-white', 'bg-info', 'border-0');
                notification.setAttribute('role', 'alert');
                notification.setAttribute('aria-live', 'assertive');
                notification.setAttribute('aria-atomic', 'true');
                notification.style.position = 'fixed';
                notification.style.bottom = '20px';
                notification.style.right = '20px';
                notification.style.zIndex = '9999';
                
                notification.innerHTML = `
                    <div class="d-flex">
                        <div class="toast-body">
                            ${message}
                        </div>
                        <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                    </div>
                `;
                
                document.body.appendChild(notification);
                
                // Show and auto-hide the notification
                const toast = new bootstrap.Toast(notification, { delay: 5000 });
                toast.show();
                
                // Remove from DOM after hiding
                notification.addEventListener('hidden.bs.toast', function() {
                    document.body.removeChild(notification);
                });
            });
        }
        // --- End Debug Level Toggle Listener ---

        if (refreshLogsBtn) {
            refreshLogsBtn.addEventListener('click', fetchContainerLogs);
        }
        
        // refreshActionLogBtn removed (integrated into main log system)

        // Smart scroll tracking for container logs
        if (logContentElement) {
            logContentElement.addEventListener('scroll', function() {
                const { scrollTop, scrollHeight, clientHeight } = this;
                const isAtBottom = scrollTop + clientHeight >= scrollHeight - 10; // 10px tolerance
                
                // Track if user scrolled up from bottom
                if (wasAtBottom && !isAtBottom) {
                    userScrolledUp = true;
                }
                wasAtBottom = isAtBottom;
                
                // Reset scroll flag if user is back at bottom
                if (isAtBottom) {
                    userScrolledUp = false;
                }
            });
        }

        // clearActionLogBtn removed (clear function integrated into main log system)

        // Load logs on page load
        setTimeout(fetchContainerLogs, 1000); // Load container logs after 1 second
        
        // Auto-refresh functionality for logs
        let autoRefreshInterval = null;
        const autoRefreshToggle = document.getElementById('autoRefreshToggle');
        const AUTO_REFRESH_INTERVAL = 10000; // 10 seconds - rate limit friendly
        
        function startAutoRefresh() {
            if (autoRefreshInterval) return; // Already running
            
            autoRefreshInterval = setInterval(async () => {
                // Only refresh if not already fetching and respecting rate limits
                const now = Date.now();
                const timeSinceLastFetch = now - lastLogFetch;
                
                if (!fetchInProgress && timeSinceLastFetch >= MIN_FETCH_INTERVAL) {
                    const currentScroll = logContentElement ? logContentElement.scrollTop : 0;
                    const wasAtBottom = logContentElement ? 
                        (logContentElement.scrollTop + logContentElement.clientHeight >= logContentElement.scrollHeight - 10) : false;
                    
                    // Add smooth transition effect
                    if (logContentElement) {
                        logContentElement.classList.add('log-updating');
                    }
                    
                    await fetchLogsByType(window.currentLogType || 'container');
                    
                    // Remove transition effect after a short delay
                    setTimeout(() => {
                        if (logContentElement) {
                            logContentElement.classList.remove('log-updating');
                        }
                    }, 200);
                    
                    // Preserve scroll position or auto-scroll to bottom
                    if (logContentElement) {
                        if (wasAtBottom) {
                            // Auto-scroll to bottom if user was at bottom
                            logContentElement.scrollTop = logContentElement.scrollHeight;
                        } else {
                            // Preserve scroll position
                            logContentElement.scrollTop = currentScroll;
                        }
                    }
                }
            }, AUTO_REFRESH_INTERVAL);
            
            console.log('Auto-refresh started');
        }
        
        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                console.log('Auto-refresh stopped');
            }
        }
        
        // Setup auto-refresh toggle
        if (autoRefreshToggle) {
            autoRefreshToggle.addEventListener('change', function() {
                const logContainer = document.querySelector('.log-display-container');
                
                if (this.checked) {
                    startAutoRefresh();
                    // Visual feedback
                    const refreshBtn = document.getElementById('refreshLogsBtn');
                    if (refreshBtn) {
                        const icon = refreshBtn.querySelector('i');
                        if (icon) {
                            icon.classList.add('text-success');
                        }
                    }
                    // Add auto-refresh indicator
                    if (logContainer) {
                        logContainer.classList.add('auto-refresh-active');
                    }
                } else {
                    stopAutoRefresh();
                    // Remove visual feedback
                    const refreshBtn = document.getElementById('refreshLogsBtn');
                    if (refreshBtn) {
                        const icon = refreshBtn.querySelector('i');
                        if (icon) {
                            icon.classList.remove('text-success');
                        }
                    }
                    // Remove auto-refresh indicator
                    if (logContainer) {
                        logContainer.classList.remove('auto-refresh-active');
                    }
                }
            });
        }
        
        // Clean up old interval if it exists
        if (logIntervalId) {
            clearInterval(logIntervalId);
            logIntervalId = null;
        }
        // --- END: Log Update ---

        // --- Enhanced Log Management Setup ---
        // Initialize log type dropdown
        const logTypeSelect = document.getElementById('logTypeSelect');
        if (logTypeSelect) {
            logTypeSelect.addEventListener('change', (e) => {
                window.currentLogType = e.target.value;
                fetchLogsByType(window.currentLogType);
            });
        }
        
        // Initialize download button
        const downloadLogsBtn = document.getElementById('downloadLogsBtn');
        if (downloadLogsBtn) {
            downloadLogsBtn.addEventListener('click', window.downloadLogs);
        }
        
        // Initialize clear button  
        const clearLogsBtn = document.getElementById('clearLogsBtn');
        if (clearLogsBtn) {
            clearLogsBtn.addEventListener('click', window.clearLogs);
        }
        
        // --- END: Enhanced Log Management Setup ---

        // --- Server Selection Table Logic ---
        const serverTableBody = document.getElementById('docker-container-list');

        if (serverTableBody) {
            // Event listener for changes to the "Active" checkboxes
            serverTableBody.addEventListener('change', function(event) {
                if (event.target.classList.contains('server-checkbox')) {
                    const row = event.target.closest('tr');
                    if (row) {
                        const isActive = event.target.checked;
                        const elementsToToggle = row.querySelectorAll('.action-checkbox, .display-name-input');
                        elementsToToggle.forEach(el => {
                            el.disabled = !isActive;
                        });
                        updateOrderNumbers(serverTableBody); // <<< Update numbering here
                        updateContainerInfoVisibility(); // Update info configuration visibility
                        showUnsavedChangesAlert(true); // Server selection requires restart
                    }
                }
            });

            // Optional: Logic for "Select All" checkbox (if needed/desired)
            const selectAllCheckbox = document.getElementById('select-all-servers');
            if (selectAllCheckbox) {
                selectAllCheckbox.addEventListener('change', function() {
                    const allServerCheckboxes = serverTableBody.querySelectorAll('.server-checkbox');
                    allServerCheckboxes.forEach(checkbox => {
                        if (checkbox.checked !== selectAllCheckbox.checked) {
                            checkbox.checked = selectAllCheckbox.checked;
                            // Manually trigger the change event to activate the row logic
                            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                    });
                });
            }
        }
        // --- END: Server Selection Table Logic ---

        // --- Server Table Sorting Logic ---
        if (serverTableBody) { 
            function updateSortButtonStates(tbody) {
                const rows = tbody.querySelectorAll('tr');
                rows.forEach((row, index) => {
                    const upBtn = row.querySelector('.move-up-btn'); // Button for "Move up" (+)
                    const downBtn = row.querySelector('.move-down-btn'); // Button for "Move down" (-)
                    if (upBtn) upBtn.disabled = (index === 0);
                    if (downBtn) downBtn.disabled = (index === rows.length - 1);
                });
            }

            // Revised helper function for updating numbers (only for active items)
            function updateOrderNumbers(tbody) {
                 const rows = tbody.querySelectorAll('tr[data-container-name]'); 
                 let activeCounter = 1; // Counter only for active items
                 rows.forEach((row) => {
                     const numSpan = row.querySelector('.order-number');
                     const isActiveCheckbox = row.querySelector('.server-checkbox');
                     
                     if (numSpan && isActiveCheckbox) {
                        if (isActiveCheckbox.checked) {
                             numSpan.textContent = activeCounter;
                             numSpan.style.visibility = 'visible';
                             activeCounter++;
                        } else {
                             numSpan.textContent = ''; // Empty for inactive items
                             numSpan.style.visibility = 'hidden'; // Hidden
                        }
                     } 
                 });
             }

            // Event Listener for clicks on Up/Down buttons (delegation)
            serverTableBody.addEventListener('click', function(event) {
                const upButton = event.target.closest('.move-up-btn');
                const downButton = event.target.closest('.move-down-btn');

                if (upButton) {
                    const currentRow = upButton.closest('tr');
                    const previousRow = currentRow.previousElementSibling;
                    if (previousRow) {
                        serverTableBody.insertBefore(currentRow, previousRow);
                        updateSortButtonStates(serverTableBody);
                        updateOrderNumbers(serverTableBody); // Update numbers
                        showUnsavedChangesAlert(true); // Order change requires restart
                    }
                }

                if (downButton) {
                    const currentRow = downButton.closest('tr');
                    const nextRow = currentRow.nextElementSibling;
                    if (nextRow) {
                        serverTableBody.insertBefore(nextRow, currentRow);
                        updateSortButtonStates(serverTableBody);
                        updateOrderNumbers(serverTableBody); // Update numbers
                        showUnsavedChangesAlert(true); // Order change requires restart
                    }
                }
            });

            // Set initial button status and numbers
            updateSortButtonStates(serverTableBody);
            updateOrderNumbers(serverTableBody); // Set initial numbering
        }
        // --- END: Server Table Sorting ---

        // --- Container Info Configuration Logic ---
        function updateContainerInfoVisibility() {
            const containerInfoConfig = document.getElementById('container-info-config');
            const containerInfoPlaceholder = document.getElementById('container-info-placeholder');
            
            if (!containerInfoConfig || !containerInfoPlaceholder) return;
            
            // Get all selected containers
            const selectedContainers = [];
            const serverCheckboxes = document.querySelectorAll('.server-checkbox:checked');
            serverCheckboxes.forEach(checkbox => {
                const row = checkbox.closest('tr');
                if (row) {
                    const containerName = row.getAttribute('data-container-name');
                    if (containerName) {
                        selectedContainers.push(containerName);
                    }
                }
            });
            
            // Show/hide container info items based on selection
            const containerInfoItems = document.querySelectorAll('.container-info-item');
            let visibleCount = 0;
            
            containerInfoItems.forEach(item => {
                const containerName = item.getAttribute('data-container-name');
                const shouldShow = selectedContainers.includes(containerName);
                
                if (shouldShow) {
                    item.style.display = 'block';
                    // Enable form elements
                    const formElements = item.querySelectorAll('input, textarea');
                    formElements.forEach(el => el.disabled = false);
                    visibleCount++;
                } else {
                    item.style.display = 'none';
                    // Disable form elements
                    const formElements = item.querySelectorAll('input, textarea');
                    formElements.forEach(el => el.disabled = true);
                }
            });
            
            // Show/hide the entire section
            if (visibleCount > 0) {
                containerInfoConfig.style.display = 'block';
                containerInfoPlaceholder.style.display = 'none';
            } else {
                containerInfoConfig.style.display = 'none';
                containerInfoPlaceholder.style.display = 'block';
            }
        }
        
        // Character counter for info text areas
        function setupCharacterCounters() {
            const textareas = document.querySelectorAll('textarea[maxlength="250"]');
            textareas.forEach(textarea => {
                const counterId = textarea.getAttribute('id');
                const counter = document.querySelector(`[data-target="${counterId}"]`);
                
                if (counter) {
                    // Update counter on input
                    textarea.addEventListener('input', function() {
                        const currentLength = this.value.length;
                        counter.textContent = currentLength;
                        
                        // Change color based on length
                        if (currentLength > 225) {
                            counter.style.color = '#dc3545'; // Red
                        } else if (currentLength > 200) {
                            counter.style.color = '#fd7e14'; // Orange
                        } else {
                            counter.style.color = ''; // Default
                        }
                    });
                    
                    // Set initial count
                    counter.textContent = textarea.value.length;
                }
            });
        }
        
        // Auto-enable /command when /control is checked (permission logic)
        function setupPermissionLogic() {
            const controlCheckboxes = document.querySelectorAll('.cmd-control');
            controlCheckboxes.forEach(controlCheckbox => {
                controlCheckbox.addEventListener('change', function() {
                    if (this.checked) {
                        // Find corresponding /command checkbox (legacy behavior)
                        const rowId = this.name.match(/\d+$/);
                        if (rowId) {
                            const commandCheckbox = document.querySelector(`input[name="cmd_command_${rowId[0]}"]`);
                            if (commandCheckbox) {
                                commandCheckbox.checked = true;
                                commandCheckbox.dispatchEvent(new Event('change', { bubbles: true }));
                            }
                        }
                    }
                });
            });
        }
        
        // Initialize container info functionality
        if (serverTableBody) {
            updateContainerInfoVisibility();
            setupCharacterCounters();
            setupPermissionLogic();
        }
        // --- END: Container Info Configuration Logic ---

        // --- Docker Container Refresh Button ---
        const refreshDockerButton = document.getElementById('refresh-docker-list');
        if (refreshDockerButton) {
            refreshDockerButton.addEventListener('click', function() {
                const button = this;
                const icon = button.querySelector('i');
                const statusText = document.getElementById('cache-status-text');
                
                // Show loading state
                button.disabled = true;
                if (icon) {
                    icon.classList.add('bi-arrow-repeat-spin'); // Add spinning animation class
                }
                if (statusText) {
                    statusText.textContent = 'Refreshing container list...';
                    statusText.style.display = 'block';
                }
                
                // Make request to refresh containers
                fetch("{{ url_for('main_bp.refresh_containers') }}", {
                    method: 'POST',
                    headers: { 'X-Requested-With': 'XMLHttpRequest' }
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Show success message briefly before reload
                        if (statusText) {
                            statusText.textContent = `Success! Found ${data.container_count} containers. Reloading...`;
                        }
                        // Reload the page after a short delay to show the success message
                        setTimeout(() => {
                            window.location.reload();
                        }, 1000);
                    } else {
                        // Show error message
                        if (statusText) {
                            statusText.textContent = 'Error: ' + (data.message || 'Failed to refresh container list');
                        }
                        // Re-enable button after error
                        button.disabled = false;
                        if (icon) {
                            icon.classList.remove('bi-arrow-repeat-spin');
                        }
                        // Hide error message after 5 seconds
                        setTimeout(() => {
                            if (statusText) {
                                statusText.style.display = 'none';
                            }
                        }, 5000);
                    }
                })
                .catch(error => {
                    console.error('Error refreshing containers:', error);
                    if (statusText) {
                        statusText.textContent = 'Error: Could not connect to server';
                    }
                    // Re-enable button after error
                    button.disabled = false;
                    if (icon) {
                        icon.classList.remove('bi-arrow-repeat-spin');
                    }
                    // Hide error message after 5 seconds
                    setTimeout(() => {
                        if (statusText) {
                            statusText.style.display = 'none';
                        }
                    }, 5000);
                });
            });
        }
        // --- END: Docker Container Refresh Button ---

        // --- MANUAL FIX: Add event listeners for language and timezone fields ---
        const languageFieldForEvents = document.getElementById('language');
        const timezoneFieldForEvents = document.getElementById('timezone');
        
        if (languageFieldForEvents) {
            console.log("Adding manual event listeners to language field");
            
            // Set userHasInteracted when field gets focus
            languageFieldForEvents.addEventListener('focus', () => {
                console.log("Language field focused - setting userHasInteracted = true");
                userHasInteracted = true;
            });
            
            // Add both input and change event listeners
            languageFieldForEvents.addEventListener('input', () => {
                console.log("Language field INPUT event triggered");
                console.log("  userHasInteracted:", userHasInteracted);
                console.log("  page loaded:", document.body.getAttribute('data-page-loaded'));
                
                // Always show alert for language changes
                if (document.body.getAttribute('data-page-loaded') === 'true') {
                    userHasInteracted = true; // Ensure it's set
                    showUnsavedChangesAlert(false); // immediate effect, no restart required
                }
            });
            
            languageFieldForEvents.addEventListener('change', () => {
                console.log("Language field CHANGE event triggered");
                console.log("  userHasInteracted:", userHasInteracted);
                console.log("  page loaded:", document.body.getAttribute('data-page-loaded'));
                
                // Always show alert for language changes
                if (document.body.getAttribute('data-page-loaded') === 'true') {
                    userHasInteracted = true; // Ensure it's set
                    showUnsavedChangesAlert(false); // immediate effect, no restart required
                }
            });
        }
        
        if (timezoneFieldForEvents) {
            console.log("Adding manual event listeners to timezone field");
            
            // Set userHasInteracted when field gets focus
            timezoneFieldForEvents.addEventListener('focus', () => {
                console.log("Timezone field focused - setting userHasInteracted = true");
                userHasInteracted = true;
            });
            
            timezoneFieldForEvents.addEventListener('input', () => {
                console.log("Timezone field INPUT event triggered");
                console.log("  userHasInteracted:", userHasInteracted);
                console.log("  page loaded:", document.body.getAttribute('data-page-loaded'));
                
                // Always show alert for timezone changes
                if (document.body.getAttribute('data-page-loaded') === 'true') {
                    userHasInteracted = true; // Ensure it's set
                    showUnsavedChangesAlert(false); // immediate effect, no restart required
                }
            });
            
            timezoneFieldForEvents.addEventListener('change', () => {
                console.log("Timezone field CHANGE event triggered");
                console.log("  userHasInteracted:", userHasInteracted);
                console.log("  page loaded:", document.body.getAttribute('data-page-loaded'));
                
                // Always show alert for timezone changes
                if (document.body.getAttribute('data-page-loaded') === 'true') {
                    userHasInteracted = true; // Ensure it's set
                    showUnsavedChangesAlert(false); // immediate effect, no restart required
                }
            });
        }
        // --- END MANUAL FIX ---

    }); // End document.addEventListener('DOMContentLoaded', ...)

    // --- Helper Functions (Defined outside DOMContentLoaded) ---

    // Function to remove a channel row
    function removeChannelRow(event) {
        const button = event.target.closest('.remove-channel-btn');
         if (!button) return;

        const rowId = button.dataset.rowId;
        const rowToRemove = document.getElementById(rowId);
        if (rowToRemove) {
            const tableBody = document.getElementById('command-permissions-table')?.querySelector('tbody');
            // Check if tableBody exists and if there is more than one row
            if (tableBody && tableBody.querySelectorAll('tr').length > 1) {
                 rowToRemove.remove();
             } else {
                 alert('Cannot delete the last channel row.');
             }
        }
    }

    // Helper to create an empty row 
    function createEmptyChannelRow(index) {
        const tr = document.createElement('tr');
        tr.id = `channel-row-${index}`;
        const defaultUpdateInterval = 5;
        const defaultInactivityTimeout = 10; 
        const defaultEnableRefresh = true;
        const defaultRecreate = true;

        // Correct string construction without template literals in HTML
        tr.innerHTML = `
            <td>
                <input type="text" class="form-control form-control-sm" name="channel_name_${index}" placeholder="Channel Name">
            </td>
            <td>
                <input type="text" class="form-control form-control-sm" name="channel_id_${index}" placeholder="Channel ID" id="channel_id_${index}">
                 <input type="hidden" name="old_channel_id_${index}" value="">
            </td>
            <td class="text-center"><div class="form-check"><input class="form-check-input cmd-serverstatus" type="checkbox" name="cmd_serverstatus_${index}" value="1"><label class="form-check-label visually-hidden">/status</label></div></td>
            <td class="text-center"><div class="form-check"><input class="form-check-input" type="checkbox" name="cmd_command_${index}" value="1"><label class="form-check-label visually-hidden">/command</label></div></td>
            <td class="text-center"><div class="form-check"><input class="form-check-input cmd-control" type="checkbox" name="cmd_control_${index}" value="1"><label class="form-check-label visually-hidden">/control</label></div></td>
            <td class="text-center"><div class="form-check"><input class="form-check-input" type="checkbox" name="cmd_schedule_${index}" value="1"><label class="form-check-label visually-hidden">/task</label></div></td>
            <td class="text-center border-start border-secondary-subtle"><div class="form-check"><input class="form-check-input" type="checkbox" name="post_initial_${index}" value="1" ${defaultRecreate ? 'checked' : ''}><label class="form-check-label visually-hidden">Initial</label></div></td>
            <td class="text-center"><div class="form-check"><input class="form-check-input auto-refresh-checkbox" type="checkbox" name="enable_auto_refresh_${index}" value="1" ${defaultEnableRefresh ? 'checked' : ''} data-target-input=".interval-minutes-input"><label class="form-check-label visually-hidden">Refresh</label></div></td>
            <td><input type="number" class="form-control form-control-sm interval-minutes-input" name="update_interval_minutes_${index}" value="${defaultUpdateInterval}" min="1" style="width: 60px; margin: auto;" ${!defaultEnableRefresh ? 'disabled' : ''}></td>
            <td class="text-center"><div class="form-check"><input class="form-check-input recreate-checkbox" type="checkbox" name="recreate_messages_on_inactivity_${index}" value="1" ${defaultRecreate ? 'checked' : ''} data-target-input=".inactivity-minutes-input"><label class="form-check-label visually-hidden">Recreate</label></div></td>
            <td><input type="number" class="form-control form-control-sm inactivity-minutes-input" name="inactivity_timeout_minutes_${index}" value="${defaultInactivityTimeout}" min="1" style="width: 60px; margin: auto;" ${!defaultRecreate ? 'disabled' : ''}></td>
            <td class="text-center">
                <button type="button" class="btn btn-sm btn-danger remove-channel-btn" data-row-id="channel-row-${index}">
                    <i class="bi bi-trash"></i>
                </button>
            </td>
        `;
        // Add listeners to the new row
        addExclusivityListeners(tr);
        handleCheckboxToggle(tr.querySelector('.auto-refresh-checkbox')); 
        handleCheckboxToggle(tr.querySelector('.recreate-checkbox'));     
        return tr;
    }

    // Helper to initialize tooltips
    function initializeTooltips(parentElement) {
        const tooltipTriggerList = parentElement.querySelectorAll('[data-bs-toggle="tooltip"]');
        tooltipTriggerList.forEach(function (tooltipTriggerEl) {
             // Remove existing tooltip if necessary to avoid duplicates
             const existingTooltip = bootstrap.Tooltip.getInstance(tooltipTriggerEl);
             if (existingTooltip) {
                 existingTooltip.dispose();
             }
             // Create new tooltip
             new bootstrap.Tooltip(tooltipTriggerEl, {
                 html: true,
                 boundary: document.body, // Prevents cutting off
                 trigger: 'hover focus' // Show on hover and focus
             });
         });
    }

    // <<< NEW: Function to enforce command exclusivity >>>
    function enforceCommandExclusivity(changedCheckbox) {
        const row = changedCheckbox.closest('tr');
        if (!row) return;

        // Use classes for easier selection
        const controlCheckbox = row.querySelector('.cmd-control');
        const serverStatusCheckbox = row.querySelector('.cmd-serverstatus');

        if (!controlCheckbox || !serverStatusCheckbox) return;

        // If the changed checkbox is the Control checkbox
        if (changedCheckbox === controlCheckbox) {
            if (controlCheckbox.checked) {
                // Control activated -> Deactivate ServerStatus (and uncheck)
                if (serverStatusCheckbox.checked) {
                    serverStatusCheckbox.checked = false;
                }
                serverStatusCheckbox.disabled = true;
                controlCheckbox.disabled = false; // Ensure this checkbox remains active
            } else {
                 // Control deactivated -> Reactivate ServerStatus
                 serverStatusCheckbox.disabled = false;
            }
        }
        // If the changed checkbox is the ServerStatus checkbox
        else if (changedCheckbox === serverStatusCheckbox) {
            if (serverStatusCheckbox.checked) {
                 // ServerStatus activated -> Deactivate Control (and uncheck)
                 if (controlCheckbox.checked) {
                     controlCheckbox.checked = false;
                 }
                 controlCheckbox.disabled = true;
                 serverStatusCheckbox.disabled = false; // Ensure this checkbox remains active
            } else {
                 // ServerStatus deactivated -> Reactivate Control
                 controlCheckbox.disabled = false;
            }
        }
    }

    // <<< NEW: Function to add event listeners for exclusivity >>>
    function addExclusivityListeners(row) {
        const controlCheckbox = row.querySelector('.cmd-control');
        const serverStatusCheckbox = row.querySelector('.cmd-serverstatus');

        if (controlCheckbox) {
            controlCheckbox.addEventListener('change', function() {
                enforceCommandExclusivity(this);
            });
            // Initial check on add/load
             if (controlCheckbox.checked) {
                 enforceCommandExclusivity(controlCheckbox);
             }
        }
        if (serverStatusCheckbox) {
            serverStatusCheckbox.addEventListener('change', function() {
                enforceCommandExclusivity(this);
            });
             // Initial check on add/load (only if control wasn't already checked)
             if (serverStatusCheckbox.checked && !(controlCheckbox && controlCheckbox.checked)) {
                 enforceCommandExclusivity(serverStatusCheckbox);
             }
        }
    }

    // AJAX save function
    function saveConfigAjax() {
        const form = document.getElementById('config-form');
        const saveButton = document.getElementById('save-config-button');
        const notification = document.getElementById('save-notification');
        if (!form || !saveButton || !notification) {
            console.error("Missing elements:", { form: !!form, saveButton: !!saveButton, notification: !!notification });
            return; // Cancel function
        }
        const originalButtonHtml = saveButton.innerHTML;
        
        console.log("=== SAVE CONFIG DEBUG START ===");
        
        // Check language and timezone fields specifically
        const languageField = document.getElementById('language');
        const timezoneField = document.getElementById('timezone');
        console.log("Language field:", languageField ? languageField.value : "NOT FOUND");
        console.log("Timezone field:", timezoneField ? timezoneField.value : "NOT FOUND");
        
        // Create FormData and manually add all form elements
        console.log("Creating FormData manually...");
        const formData = new FormData();
        
        // First add all normal form fields
        const formElements = form.querySelectorAll('input, select, textarea');
        console.log(`Found ${formElements.length} form elements`);
        
        formElements.forEach(element => {
            // Skip checkboxes with name="selected_servers", which we handle separately
            if (element.name === 'selected_servers') {
                return;
            }
            
            // Debug output for language and timezone fields
            if (element.name === 'language' || element.name === 'timezone') {
                console.log(`Processing ${element.name}: ${element.value}`);
            }
            
            // Special debug for language field
            if (element.id === 'language' || element.name === 'language') {
                console.log(`LANGUAGE FIELD DEBUG:`);
                console.log(`  ID: ${element.id}`);
                console.log(`  Name: ${element.name}`);
                console.log(`  Value: ${element.value}`);
                console.log(`  Type: ${element.type}`);
                console.log(`  TagName: ${element.tagName}`);
            }
            
            // For checkboxes, only set the value if they are checked
            if (element.type === 'checkbox') {
                formData.set(element.name, element.checked ? (element.value || "1") : "0");
            }
            // For radio buttons, only set if checked
            else if (element.type === 'radio') {
                if (element.checked) {
                    formData.set(element.name, element.value);
                }
            }
            // For normal fields, simply use the value
            else if (element.name) {
                formData.set(element.name, element.value);
                // Extra debug for language/timezone
                if (element.name === 'language' || element.name === 'timezone') {
                    console.log(`ADDED TO FORMDATA: ${element.name} = ${element.value}`);
                }
            }
        });
        
        console.log("=== MANUAL TEST END ===");
        
        // --- NEW: Capture server configuration --- 
        const serverTableBody = document.getElementById('docker-container-list');
        const orderedServerNames = [];
        const selectedServerNames = [];
        
        // MANUAL FIX: Add language and timezone fields manually if they're not in the form
        const languageFieldReal = document.getElementById('language');
        const timezoneFieldReal = document.getElementById('timezone');
        
        if (languageFieldReal) {
            console.log(`MANUAL ADD (REAL): Adding language field: ${languageFieldReal.value}`);
            formData.set('language', languageFieldReal.value);
        }
        
        if (timezoneFieldReal) {
            console.log(`MANUAL ADD (REAL): Adding timezone field: ${timezoneFieldReal.value}`);
            formData.set('timezone', timezoneFieldReal.value);
        }
        
        if (serverTableBody) {
            console.log("Server table found, processing server configuration...");
            
            // First phase: First collect all activated containers in the correct order
            const activeRows = [];
            const inactiveRows = [];
            
            // Sort rows into active and inactive
            serverTableBody.querySelectorAll('tr[data-container-name]').forEach((row) => {
                const checkbox = row.querySelector('.server-checkbox');
                if (checkbox && checkbox.checked) {
                    activeRows.push(row);
                } else {
                    inactiveRows.push(row);
                }
            });
            
            // Sort active rows by their numbering
            activeRows.sort((a, b) => {
                const numA = a.querySelector('.order-number')?.textContent || "999";
                const numB = b.querySelector('.order-number')?.textContent || "999";
                return parseInt(numA) - parseInt(numB);
            });
            
            // First collect all active containers in order
            activeRows.forEach((row) => {
                const containerName = row.getAttribute('data-container-name');
                if (!containerName) return;
                
                orderedServerNames.push(containerName);
                selectedServerNames.push(containerName);
                console.log(`Active container #${orderedServerNames.length}: ${containerName}`);
                
                // Collect actions
                const actions = [];
                
                // Status action
                const statusCheckbox = row.querySelector('input[name="allow_status_' + containerName + '"]');
                if (statusCheckbox) {
                    console.log(`[DEBUG] ${containerName} Status checkbox found: checked=${statusCheckbox.checked}`);
                    if (statusCheckbox.checked) {
                        actions.push("status");
                        formData.append('allow_status_' + containerName, '1');
                        console.log(`[DEBUG] ${containerName} Status: ALLOWED (sending '1')`);
                    } else {
                        // CRITICAL: Also send '0' for unchecked boxes
                        formData.append('allow_status_' + containerName, '0');
                        console.log(`[DEBUG] ${containerName} Status: DENIED (sending '0')`);
                    }
                } else {
                    console.log(`[DEBUG] ${containerName} Status checkbox NOT FOUND`);
                }
                
                // Start action
                const startCheckbox = row.querySelector('input[name="allow_start_' + containerName + '"]');
                if (startCheckbox) {
                    console.log(`[DEBUG] ${containerName} Start checkbox found: checked=${startCheckbox.checked}`);
                    if (startCheckbox.checked) {
                        actions.push("start");
                        formData.append('allow_start_' + containerName, '1');
                        console.log(`[DEBUG] ${containerName} Start: ALLOWED (sending '1')`);
                    } else {
                        // CRITICAL: Also send '0' for unchecked boxes
                        formData.append('allow_start_' + containerName, '0');
                        console.log(`[DEBUG] ${containerName} Start: DENIED (sending '0')`);
                    }
                } else {
                    console.log(`[DEBUG] ${containerName} Start checkbox NOT FOUND`);
                }
                
                // Stop action
                const stopCheckbox = row.querySelector('input[name="allow_stop_' + containerName + '"]');
                if (stopCheckbox) {
                    console.log(`[DEBUG] ${containerName} Stop checkbox found: checked=${stopCheckbox.checked}`);
                    if (stopCheckbox.checked) {
                        actions.push("stop");
                        formData.append('allow_stop_' + containerName, '1');
                        console.log(`[DEBUG] ${containerName} Stop: ALLOWED (sending '1')`);
                    } else {
                        // CRITICAL: Also send '0' for unchecked boxes
                        formData.append('allow_stop_' + containerName, '0');
                        console.log(`[DEBUG] ${containerName} Stop: DENIED (sending '0')`);
                    }
                } else {
                    console.log(`[DEBUG] ${containerName} Stop checkbox NOT FOUND`);
                }
                
                // Restart action
                const restartCheckbox = row.querySelector('input[name="allow_restart_' + containerName + '"]');
                if (restartCheckbox) {
                    console.log(`[DEBUG] ${containerName} Restart checkbox found: checked=${restartCheckbox.checked}`);
                    if (restartCheckbox.checked) {
                        actions.push("restart");
                        formData.append('allow_restart_' + containerName, '1');
                        console.log(`[DEBUG] ${containerName} Restart: ALLOWED (sending '1')`);
                    } else {
                        // CRITICAL: Also send '0' for unchecked boxes
                        formData.append('allow_restart_' + containerName, '0');
                        console.log(`[DEBUG] ${containerName} Restart: DENIED (sending '0')`);
                    }
                } else {
                    console.log(`[DEBUG] ${containerName} Restart checkbox NOT FOUND`);
                }
                
                console.log(`Container '${containerName}' allowed actions: ${actions.join(', ')}`);
                
                // Display Name
                const displayNameInput = row.querySelector('input[name="display_name_' + containerName + '"]');
                if (displayNameInput) {
                    formData.append('display_name_' + containerName, displayNameInput.value || containerName);
                }
            });
            
            // Then add inactive containers
            inactiveRows.forEach((row) => {
                const containerName = row.getAttribute('data-container-name');
                if (!containerName) return;
                
                orderedServerNames.push(containerName);
                console.log(`Inactive container added: ${containerName}`);
            });
            
            // Ordered list as string
            formData.append('server_order', orderedServerNames.join('__,__'));
            console.log(`Server order: ${orderedServerNames.join(', ')}`);
            
            // Selected servers
            selectedServerNames.forEach(serverName => {
                formData.append('selected_servers', serverName);
            });
            console.log(`Selected servers (${selectedServerNames.length}): ${selectedServerNames.join(', ')}`);
        } else {
            console.error("Server table not found!");
        }
        
        // --- NEW: Capture channel configuration ---
        console.log("Processing channel configuration...");
        const channelTable = document.getElementById('command-permissions-table');
        if (channelTable) {
            const channelRows = channelTable.querySelectorAll('tbody tr');
            console.log(`Found ${channelRows.length} channel rows`);
            
            channelRows.forEach((row, index) => {
                const rowIndex = index + 1; // 1-based indexing
                
                // Channel Name
                const channelNameInput = row.querySelector(`input[name="channel_name_${rowIndex}"]`);
                if (channelNameInput) {
                    formData.set(`channel_name_${rowIndex}`, channelNameInput.value || '');
                    console.log(`Channel ${rowIndex} name: ${channelNameInput.value}`);
                }
                
                // Channel ID
                const channelIdInput = row.querySelector(`input[name="channel_id_${rowIndex}"]`);
                if (channelIdInput) {
                    formData.set(`channel_id_${rowIndex}`, channelIdInput.value || '');
                    console.log(`Channel ${rowIndex} ID: ${channelIdInput.value}`);
                }
                
                // Command permissions
                ['serverstatus', 'command', 'control', 'schedule'].forEach(cmd => {
                    const cmdCheckbox = row.querySelector(`input[name="cmd_${cmd}_${rowIndex}"]`);
                    if (cmdCheckbox) {
                        formData.set(`cmd_${cmd}_${rowIndex}`, cmdCheckbox.checked ? '1' : '0');
                        console.log(`Channel ${rowIndex} cmd_${cmd}: ${cmdCheckbox.checked ? '1' : '0'}`);
                    }
                });
                
                // Other channel settings
                const settingsMap = {
                    'post_initial': 'post_initial',
                    'enable_auto_refresh': 'enable_auto_refresh', 
                    'recreate_messages_on_inactivity': 'recreate_messages_on_inactivity'
                };
                
                Object.entries(settingsMap).forEach(([setting, formName]) => {
                    const checkbox = row.querySelector(`input[name="${formName}_${rowIndex}"]`);
                    if (checkbox) {
                        formData.set(`${formName}_${rowIndex}`, checkbox.checked ? '1' : '0');
                        console.log(`Channel ${rowIndex} ${formName}: ${checkbox.checked ? '1' : '0'}`);
                    }
                });
                
                // Numeric settings
                const numericSettings = ['update_interval_minutes', 'inactivity_timeout_minutes'];
                numericSettings.forEach(setting => {
                    const input = row.querySelector(`input[name="${setting}_${rowIndex}"]`);
                    if (input) {
                        formData.set(`${setting}_${rowIndex}`, input.value || '1');
                        console.log(`Channel ${rowIndex} ${setting}: ${input.value}`);
                    }
                });
            });
        } else {
            console.log("Channel permissions table not found");
        }
        
        // Add information about split configuration files
        formData.append('config_split_enabled', '1');

        // Hide unsaved changes alert when starting to save
        hideUnsavedChangesAlert();

        // Visual feedback
        saveButton.disabled = true;
        saveButton.innerHTML = `<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Saving...`;
        notification.style.display = 'none';
        
        // Output of all FormData values in console for debugging purposes
        console.log("FormData content before sending:");
        for (let [key, value] of formData.entries()) {
            console.log(`${key}: ${value}`);
        }

        fetch("{{ url_for('main_bp.save_config_api') }}", {
            method: 'POST',
            body: formData,
            headers: { 'X-Requested-With': 'XMLHttpRequest' }
        })
        .then(response => { 
            if (!response.ok) {
                 return response.json()
                     .then(errData => {
                         const message = errData.message || errData.error || `HTTP error ${response.status}`;
                         throw new Error(message);
                      })
                     .catch((jsonParseError) => {
                         throw new Error(`HTTP error ${response.status}`);
                      });
             }
            return response.json();
         })
        .then(data => {
             if (data.success) {
                 notification.textContent = data.message || 'Configuration saved successfully!';
                 notification.className = 'alert alert-success';
                 notification.style.display = 'block';
                 hideUnsavedChangesAlert();
                 hasUnsavedChanges = false; // Reset flag
                 
                 // Show special message if critical settings changed
                 if (data.critical_settings_changed) {
                     const criticalMessage = document.createElement('div');
                     criticalMessage.className = 'small mt-2 text-success';
                     criticalMessage.innerHTML = '<i class="bi bi-check-circle"></i> <strong>Critical settings updated:</strong> Language/timezone changes are now active without restart!';
                     notification.appendChild(criticalMessage);
                 }
                 
                 // Show restart message only if necessary and if changes 
                 // were actually made to critical elements
                 if (restartRequired) {
                     if (document.querySelectorAll('.requires-restart').length > 0) {
                         // Check if changes were actually made to a critical element
                         let changesDetected = false;
                         document.querySelectorAll('.requires-restart').forEach(element => {
                             // For checkboxes: The original setting was changed by saving
                             if (element.type === 'checkbox' && element.checked) {
                                 changesDetected = true;
                             }
                             // For input fields: If not empty, there was a change
                             else if (element.value && element.value.trim() !== '') {
                                 changesDetected = true;
                             }
                         });
                         
                         if (changesDetected) {
                             showRestartRequiredAlert();
                         }
                     }
                     
                     restartRequired = false; // Reset after successful saving
                 }
                 
                 // Display new information about split configuration
                 if (data.config_files && data.config_files.length > 0) {
                     const configList = document.createElement('div');
                     configList.className = 'small mt-2';
                     configList.innerHTML = 'Saved configuration files: ' + 
                         data.config_files.map(file => `<code>${file}</code>`).join(', ');
                     notification.appendChild(configList);
                 }
             } else {
                 throw new Error(data.message || 'An unknown error occurred while saving.');
             }
         })
         .catch(error => {
             notification.textContent = `Error: ${error.message}`;
             notification.className = 'alert alert-danger';
             notification.style.display = 'block';
         })
         .finally(() => {
            if (saveButton) { 
                 saveButton.disabled = false;
                 saveButton.innerHTML = originalButtonHtml; // Restore original button text
             } else {
                 console.error("Save button element was not found in .finally()!");
             }
             setTimeout(() => {
                  if (notification && notification.style.display !== 'none') { // Additional check for notification
                      notification.style.display = 'none';
                  }
              }, 7000); // 7 seconds
         });
    }

    // Function to show/hide Channel ID based on method (No longer needed)
    /* function toggleChannelId() {
        const methodSelect = document.getElementById('heartbeat_method');
        const channelIdGroup = document.getElementById('heartbeat-channel-id-group'); // Assuming this ID exists for the div/group

        if (methodSelect && channelIdGroup) {
            if (methodSelect.value === 'channel') {
                channelIdGroup.style.display = ''; // Show the group
            } else {
                channelIdGroup.style.display = 'none'; // Hide the group
            }
        }
    } */

    // --- Enhanced Log Management Functions ---
    
    // Store current log type (moved to global scope)
    window.currentLogType = 'container';
    
    // Function to fetch logs based on selected type
    async function fetchLogsByType(logType) {
        const logContentElement = document.getElementById('logContent');
        const logTitle = document.getElementById('logTitle');
        const logTimestamp = document.getElementById('logTimestamp');
        const refreshLogsBtn = document.getElementById('refreshLogsBtn');
        
        if (!logContentElement) return false;
        
        // Set fetch in progress flag and update timestamp
        if (typeof fetchInProgress !== 'undefined') {
            fetchInProgress = true;
        }
        if (typeof lastLogFetch !== 'undefined') {
            lastLogFetch = Date.now();
        }
        
        // Update title based on log type
        const titles = {
            'container': 'Container Logs',
            'bot': 'Bot Logs',
            'discord': 'Discord Bot Logs',
            'webui': 'Web UI Logs',
            'application': 'Application Logs',
            'actions': 'User Action Log'
        };
        
        if (logTitle) {
            logTitle.textContent = `${titles[logType] || 'Logs'} (last 500 lines)`;
        }
        
        // Disable refresh button during fetch (only if not auto-refreshing)
        const autoRefreshToggle = document.getElementById('autoRefreshToggle');
        if (refreshLogsBtn && (!autoRefreshToggle || !autoRefreshToggle.checked)) {
            refreshLogsBtn.disabled = true;
        }
        
        // Store current content for smooth transition
        const currentContent = logContentElement.innerHTML;
        
        // Only show loading state if not auto-refreshing and no content exists
        if ((!autoRefreshToggle || !autoRefreshToggle.checked) && !currentContent) {
            logContentElement.innerHTML = '<span class="text-muted">Loading logs...</span>';
        }
        
        try {
            let endpoint = '';
            switch(logType) {
                case 'container':
                    endpoint = "{{ url_for('log_bp.get_container_logs', container_name='dockerdiscordcontrol') }}";
                    break;
                case 'bot':
                    endpoint = "{{ url_for('log_bp.get_bot_logs') }}";
                    break;
                case 'discord':
                    endpoint = "{{ url_for('log_bp.get_discord_logs') }}";
                    break;
                case 'webui':
                    endpoint = "{{ url_for('log_bp.get_webui_logs') }}";
                    break;
                case 'application':
                    endpoint = "{{ url_for('log_bp.get_application_logs') }}";
                    break;
                case 'actions':
                    endpoint = "{{ url_for('log_bp.get_action_logs') }}";
                    break;
                default:
                    endpoint = "{{ url_for('log_bp.get_container_logs', container_name='dockerdiscordcontrol') }}";
            }
            
            const response = await fetch(endpoint);
            if (response.ok) {
                const logs = await response.text();
                // Directly display logs without filtering for now
                logContentElement.textContent = logs;
                
                // Update timestamp
                if (logTimestamp) {
                    const now = new Date();
                    logTimestamp.textContent = `Last updated: ${now.toLocaleTimeString()}`;
                }
                return true;
            } else {
                logContentElement.innerHTML = `<span class="text-danger">Error loading logs: ${response.statusText}</span>`;
            }
        } catch (error) {
            console.error('Error fetching logs:', error);
            // Only show error if not auto-refreshing
            const autoRefreshToggle = document.getElementById('autoRefreshToggle');
            if (!autoRefreshToggle || !autoRefreshToggle.checked) {
                logContentElement.innerHTML = `<span class="text-danger">Error loading logs: ${error.message}</span>`;
            }
        } finally {
            // Reset fetch in progress flag
            if (typeof fetchInProgress !== 'undefined') {
                fetchInProgress = false;
            }
            
            // Re-enable refresh button after delay (only if not auto-refreshing)
            const autoRefreshToggle = document.getElementById('autoRefreshToggle');
            if (refreshLogsBtn && (!autoRefreshToggle || !autoRefreshToggle.checked)) {
                setTimeout(() => {
                    refreshLogsBtn.disabled = false;
                }, 1000);
            }
        }
        return false;
    }
    
    // Function to download current logs (global scope)
    window.downloadLogs = function() {
        const logContent = document.getElementById('logContent');
        const logTypeSelect = document.getElementById('logTypeSelect');
        
        if (!logContent) return;
        
        const logType = logTypeSelect ? logTypeSelect.value : 'container';
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `${logType}_logs_${timestamp}.txt`;
        
        // Get the text content (removing HTML)
        const content = logContent.textContent || logContent.innerText;
        
        // Create blob and download
        const blob = new Blob([content], { type: 'text/plain' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
        
        // Show notification
        const notification = document.getElementById('save-notification');
        if (notification) {
            notification.className = 'alert alert-info';
            notification.textContent = `Logs downloaded as ${filename}`;
            notification.style.display = 'block';
            setTimeout(() => { notification.style.display = 'none'; }, 3000);
        }
    }
    
    // Function to clear logs (global scope)
    window.clearLogs = async function() {
        const logTypeSelect = document.getElementById('logTypeSelect');
        const logType = logTypeSelect ? logTypeSelect.value : 'container';
        
        if (!confirm(`Are you sure you want to clear ${logType} logs? This action cannot be undone.`)) {
            return;
        }
        
        // For now, just clear the display - can be updated when backend endpoint is available
        const logContent = document.getElementById('logContent');
        if (logContent) {
            logContent.innerHTML = '<span class="text-muted">Logs cleared</span>';
            // Clear cache if it exists
            if (typeof window.rawLogsCache !== 'undefined') {
                window.rawLogsCache = '';
            }
        }
        
        // Show notification
        const notification = document.getElementById('save-notification');
        if (notification) {
            notification.className = 'alert alert-success';
            notification.textContent = `${logType} logs cleared successfully`;
            notification.style.display = 'block';
            setTimeout(() => { notification.style.display = 'none'; }, 3000);
        }
    }

    // --- Temporary Debug Mode Functions ---
    
    // Timer for refreshing the temporary debug status
    let tempDebugStatusTimer = null;
    
    // Function to refresh the temporary debug status
    function refreshTempDebugStatus() {
        fetch("{{ url_for('main_bp.temp_debug_status') }}", {
            method: 'GET',
            headers: { 'X-Requested-With': 'XMLHttpRequest' }
        })
        .then(response => response.json())
        .then(data => {
            const statusElement = document.getElementById('tempDebugStatus');
            const enableButton = document.getElementById('enableTempDebugBtn');
            
            if (data.success) {
                if (data.is_enabled) {
                    // Debug is active
                    statusElement.innerHTML = `
                        <span class="text-warning">
                            <i class="bi bi-stopwatch"></i> 
                            Debug active for ${data.remaining_formatted} 
                            (expires at ${data.expiry_formatted})
                        </span>
                        <button type="button" id="disableTempDebugBtn" class="btn btn-sm btn-link text-danger p-0 ms-2">
                            <i class="bi bi-x-circle"></i> Disable
                        </button>
                    `;
                    enableButton.disabled = true;
                    
                    // Add event listener to the disable button
                    const disableButton = document.getElementById('disableTempDebugBtn');
                    if (disableButton) {
                        disableButton.addEventListener('click', disableTempDebug);
                    }
                    
                    // Continue polling if debug is active
                    if (tempDebugStatusTimer) clearTimeout(tempDebugStatusTimer);
                    tempDebugStatusTimer = setTimeout(refreshTempDebugStatus, 5000); // Check every 5 seconds
                } else {
                    // Debug is inactive
                    statusElement.innerHTML = `<span class="text-muted">Temporary debug mode is inactive</span>`;
                    enableButton.disabled = false;
                    
                    // Stop polling if debug is inactive
                    if (tempDebugStatusTimer) {
                        clearTimeout(tempDebugStatusTimer);
                        tempDebugStatusTimer = null;
                    }
                }
            } else {
                // Error occurred
                statusElement.innerHTML = `<span class="text-danger">Error: ${data.message}</span>`;
                enableButton.disabled = false;
            }
        })
        .catch(error => {
            console.error("Error fetching temp debug status:", error);
            const statusElement = document.getElementById('tempDebugStatus');
            statusElement.innerHTML = `<span class="text-danger">Error checking status</span>`;
            
            // Stop polling on error
            if (tempDebugStatusTimer) {
                clearTimeout(tempDebugStatusTimer);
                tempDebugStatusTimer = null;
            }
        });
    }
    
    // Function to enable temporary debug mode
    function enableTempDebug() {
        const durationSelect = document.getElementById('tempDebugDuration');
        const duration = durationSelect ? durationSelect.value : '10';
        const statusElement = document.getElementById('tempDebugStatus');
        
        statusElement.innerHTML = `<span class="text-info"><i class="bi bi-hourglass-split"></i> Enabling temporary debug mode...</span>`;
        
        const formData = new FormData();
        formData.append('duration', duration);
        
        fetch("{{ url_for('main_bp.enable_temp_debug') }}", {
            method: 'POST',
            body: formData,
            headers: { 'X-Requested-With': 'XMLHttpRequest' }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Show success notification
                const notification = document.getElementById('save-notification');
                if (notification) {
                    notification.className = 'alert alert-warning';
                    notification.textContent = data.message;
                    notification.style.display = 'block';
                    setTimeout(() => { notification.style.display = 'none'; }, 5000);
                }
                
                // Refresh the status display
                refreshTempDebugStatus();
            } else {
                statusElement.innerHTML = `<span class="text-danger">Error: ${data.message}</span>`;
            }
        })
        .catch(error => {
            console.error("Error enabling temp debug:", error);
            statusElement.innerHTML = `<span class="text-danger">Error enabling temporary debug mode</span>`;
        });
    }
    
    // Function to disable temporary debug mode
    function disableTempDebug() {
        const statusElement = document.getElementById('tempDebugStatus');
        statusElement.innerHTML = `<span class="text-info"><i class="bi bi-hourglass-split"></i> Disabling temporary debug mode...</span>`;
        
        fetch("{{ url_for('main_bp.disable_temp_debug') }}", {
            method: 'POST',
            headers: { 'X-Requested-With': 'XMLHttpRequest' }
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Show success notification
                const notification = document.getElementById('save-notification');
                if (notification) {
                    notification.className = 'alert alert-info';
                    notification.textContent = data.message;
                    notification.style.display = 'block';
                    setTimeout(() => { notification.style.display = 'none'; }, 5000);
                }
                
                // Refresh the status display
                refreshTempDebugStatus();
            } else {
                statusElement.innerHTML = `<span class="text-danger">Error: ${data.message}</span>`;
            }
        })
        .catch(error => {
            console.error("Error disabling temp debug:", error);
            statusElement.innerHTML = `<span class="text-danger">Error disabling temporary debug mode</span>`;
        });
    }
    
    // Test function that can be called manually from browser console
    window.testLanguageSave = function() {
        console.log("=== MANUAL TEST START ===");
        
        const form = document.getElementById('config-form');
        const languageField = document.getElementById('language');
        const timezoneField = document.getElementById('timezone');
        
        console.log("Form found:", !!form);
        console.log("Language field found:", !!languageField);
        console.log("Timezone field found:", !!timezoneField);
        
        // Extended debug: Check if language field is inside the form
        if (languageField && form) {
            console.log("Language field is inside form:", form.contains(languageField));
            console.log("Language field parent form:", languageField.form === form);
        }
        
        if (languageField) {
            console.log("Current language value:", languageField.value);
            console.log("Setting language to 'de'...");
            languageField.value = 'de';
            console.log("New language value:", languageField.value);
            
            // Trigger change event
            languageField.dispatchEvent(new Event('change', { bubbles: true }));
            console.log("Change event dispatched");
        }
        
        // Test form data collection using the SAME logic as saveConfigAjax
        if (form) {
            console.log("Creating FormData manually (same as saveConfigAjax)...");
            const formData = new FormData();
            
            // First add all normal form fields (EXACT same logic as saveConfigAjax)
            const formElements = form.querySelectorAll('input, select, textarea');
            console.log(`Found ${formElements.length} form elements`);
            
            // Count elements by type
            let inputCount = 0, selectCount = 0, textareaCount = 0;
            let languageFound = false, timezoneFound = false;
            
            formElements.forEach(element => {
                if (element.tagName === 'INPUT') inputCount++;
                if (element.tagName === 'SELECT') selectCount++;
                if (element.tagName === 'TEXTAREA') textareaCount++;
                
                if (element.name === 'language') languageFound = true;
                if (element.name === 'timezone') timezoneFound = true;
                
                // Skip checkboxes with name="selected_servers", which we handle separately
                if (element.name === 'selected_servers') {
                    return;
                }
                
                // Debug output for language and timezone fields
                if (element.name === 'language' || element.name === 'timezone') {
                    console.log(`Processing ${element.name}: ${element.value}`);
                }
                
                // Special debug for language field
                if (element.id === 'language' || element.name === 'language') {
                    console.log(`LANGUAGE FIELD DEBUG:`);
                    console.log(`  ID: ${element.id}`);
                    console.log(`  Name: ${element.name}`);
                    console.log(`  Value: ${element.value}`);
                    console.log(`  Type: ${element.type}`);
                    console.log(`  TagName: ${element.tagName}`);
                }
                
                // For checkboxes, only set the value if they are checked
                if (element.type === 'checkbox') {
                    formData.set(element.name, element.checked ? (element.value || "1") : "0");
                }
                // For radio buttons, only set if checked
                else if (element.type === 'radio') {
                    if (element.checked) {
                        formData.set(element.name, element.value);
                    }
                }
                // For normal fields, simply use the value
                else if (element.name) {
                    formData.set(element.name, element.value);
                    // Extra debug for language/timezone
                    if (element.name === 'language' || element.name === 'timezone') {
                        console.log(`ADDED TO FORMDATA: ${element.name} = ${element.value}`);
                    }
                }
            });
            
            console.log(`Element counts: INPUT=${inputCount}, SELECT=${selectCount}, TEXTAREA=${textareaCount}`);
            console.log(`Language found in form: ${languageFound}`);
            console.log(`Timezone found in form: ${timezoneFound}`);
            
            // MANUAL FIX: Add language and timezone fields manually if they're not in the form
            const languageField = document.getElementById('language');
            const timezoneField = document.getElementById('timezone');
            
            if (languageField && !languageFound) {
                console.log(`MANUAL ADD: Adding language field manually: ${languageField.value}`);
                formData.set('language', languageField.value);
            }
            
            if (timezoneField && !timezoneFound) {
                console.log(`MANUAL ADD: Adding timezone field manually: ${timezoneField.value}`);
                formData.set('timezone', timezoneField.value);
            }
            
            console.log("FormData entries:");
            let entryCount = 0;
            for (let [key, value] of formData.entries()) {
                if (key === 'language' || key === 'timezone' || entryCount < 10) {
                    console.log(`${key}: ${value}`);
                }
                entryCount++;
            }
            console.log(`Total entries: ${entryCount}`);
        }
        
        console.log("=== MANUAL TEST END ===");
    };
    
    // Direct save test function
    window.testDirectSave = function() {
        console.log("=== DIRECT SAVE TEST ===");
        
        // Set language to German first
        const languageField = document.getElementById('language');
        if (languageField) {
            console.log("Setting language to 'de'...");
            languageField.value = 'de';
        }
        
        // Call saveConfigAjax directly
        console.log("Calling saveConfigAjax()...");
        saveConfigAjax();
    };

    // Test event listeners
    window.testEventListeners = function() {
        console.log("=== EVENT LISTENER TEST ===");
        
        const languageField = document.getElementById('language');
        if (!languageField) {
            console.error("Language field not found!");
            return;
        }
        
        console.log("Language field found");
        console.log("Classes:", languageField.className);
        console.log("Has requires-restart class:", languageField.classList.contains('requires-restart'));
        console.log("data-immediate-effect:", languageField.getAttribute('data-immediate-effect'));
        
        // Check if event listeners are attached
        console.log("Triggering change event...");
        const oldValue = languageField.value;
        languageField.value = oldValue === 'en' ? 'de' : 'en';
        
        // Trigger both input and change events
        languageField.dispatchEvent(new Event('input', { bubbles: true }));
        languageField.dispatchEvent(new Event('change', { bubbles: true }));
        
        console.log("Events triggered. Check if unsaved changes alert appeared.");
        
        // Check alert state
        const unsavedAlert = document.getElementById('unsaved-changes-alert');
        if (unsavedAlert) {
            console.log("Unsaved changes alert exists");
            console.log("Alert visible:", !unsavedAlert.classList.contains('force-hide'));
            console.log("Alert display style:", unsavedAlert.style.display);
        } else {
            console.error("Unsaved changes alert element not found!");
        }
        
        console.log("=== END EVENT LISTENER TEST ===");
    };

    // Test save button functionality
    window.testSaveButton = function() {
        console.log("=== SAVE BUTTON TEST ===");
        
        const saveButton = document.getElementById('save-config-button');
        const floatingSaveButton = document.getElementById('floating-save-button');
        
        console.log("Main save button found:", !!saveButton);
        console.log("Floating save button found:", !!floatingSaveButton);
        
        if (saveButton) {
            console.log("Main save button:");
            console.log("  ID:", saveButton.id);
            console.log("  Type:", saveButton.type);
            console.log("  Disabled:", saveButton.disabled);
            console.log("  OnClick:", saveButton.onclick);
            
            // Check for event listeners
            const listeners = getEventListeners ? getEventListeners(saveButton) : "getEventListeners not available";
            console.log("  Event listeners:", listeners);
            
            // Try clicking it
            console.log("Clicking main save button...");
            saveButton.click();
        } else {
            console.error("Main save button not found!");
        }
        
        console.log("=== END SAVE BUTTON TEST ===");
    };

    // Comprehensive save button debug
    window.debugSaveButtons = function() {
        console.log("=== COMPREHENSIVE SAVE BUTTON DEBUG ===");
        
        // Find all save-related buttons
        const mainSaveButton = document.getElementById('save-config-button');
        const floatingSaveButton = document.getElementById('floating-save-button');
        const allButtons = document.querySelectorAll('button');
        
        console.log("Main save button:", mainSaveButton);
        console.log("Floating save button:", floatingSaveButton);
        console.log("Total buttons on page:", allButtons.length);
        
        // Check for buttons with save-related text
        allButtons.forEach(btn => {
            if (btn.textContent.toLowerCase().includes('save')) {
                console.log("Found save-related button:", {
                    id: btn.id,
                    text: btn.textContent,
                    type: btn.type,
                    disabled: btn.disabled,
                    onclick: btn.onclick,
                    parent: btn.parentElement?.tagName
                });
            }
        });
        
        // Check if saveConfigAjax function exists
        console.log("saveConfigAjax function exists:", typeof saveConfigAjax === 'function');
        
        // Try to directly call saveConfigAjax
        if (typeof saveConfigAjax === 'function') {
            console.log("Calling saveConfigAjax directly...");
            try {
                saveConfigAjax();
            } catch (e) {
                console.error("Error calling saveConfigAjax:", e);
            }
        }
        
        console.log("=== END DEBUG ===");
    };

    // Test language/timezone event listeners
    window.testLanguageEvents = function() {
        console.log("=== TESTING LANGUAGE/TIMEZONE EVENTS ===");
        
        const languageField = document.getElementById('language');
        const timezoneField = document.getElementById('timezone');
        const pageLoaded = document.body.getAttribute('data-page-loaded');
        
        console.log("Language field found:", !!languageField);
        console.log("Timezone field found:", !!timezoneField);
        console.log("userHasInteracted (global):", userHasInteracted);
        console.log("pageLoaded:", pageLoaded);
        
        // Force user interaction
        console.log("Forcing userHasInteracted = true");
        userHasInteracted = true;
        
        // Check if listeners are attached using browser dev tools
        if (languageField) {
            // Try to trigger events manually
            console.log("Triggering manual change on language field...");
            const oldValue = languageField.value;
            languageField.value = oldValue === 'en' ? 'de' : 'en';
            
            // Dispatch events
            languageField.dispatchEvent(new Event('input', { bubbles: true }));
            languageField.dispatchEvent(new Event('change', { bubbles: true }));
            
            // Check alert
            setTimeout(() => {
                const alert = document.getElementById('unsaved-changes-alert');
                console.log("Alert visible after language change:", alert && !alert.classList.contains('force-hide'));
                console.log("Alert display style:", alert ? alert.style.display : "alert not found");
                
                // Restore original value
                languageField.value = oldValue;
            }, 100);
        }
        
        console.log("=== END TEST ===");
    };

    // Professional Log Auto-refresh Manager
    class LogAutoRefresh {
        constructor() {
            this.isEnabled = false;
            this.refreshInterval = null;
            this.defaultInterval = 30000; // 30 seconds
            this.lastContainerLogHash = null;
            this.lastActionLogHash = null;
            this.isVisible = true;
            this.hasErrors = false;
            
            this.setupVisibilityTracking();
            this.startAutoRefresh();
        }
        
        setupVisibilityTracking() {
            // Track page visibility to pause auto-refresh when page is hidden
            document.addEventListener('visibilitychange', () => {
                this.isVisible = !document.hidden;
                if (this.isVisible && this.isEnabled) {
                    console.log('Page visible, resuming log auto-refresh');
                    this.refreshLogs();
                }
            });
        }
        
        startAutoRefresh() {
            if (this.refreshInterval) return;
            
            this.isEnabled = true;
            this.refreshInterval = setInterval(() => {
                if (this.isVisible && !this.hasErrors) {
                    this.refreshLogs();
                }
            }, this.defaultInterval);
            
            console.log('Log auto-refresh started (30s interval)');
        }
        
        stopAutoRefresh() {
            if (this.refreshInterval) {
                clearInterval(this.refreshInterval);
                this.refreshInterval = null;
                this.isEnabled = false;
                console.log('Log auto-refresh stopped');
            }
        }
        
        async refreshLogs() {
            if (!this.isVisible) return;
            
            try {
                // Smart refresh: only update if content changed
                await this.smartRefreshContainerLogs();
                
                // Stagger action log refresh by 2 seconds
                setTimeout(() => {
                    if (this.isVisible) {
                        this.smartRefreshActionLogs();
                    }
                }, 2000);
                
                this.hasErrors = false;
            } catch (error) {
                console.error('Auto-refresh error:', error);
                this.hasErrors = true;
                
                // Auto-retry after 60 seconds on error
                setTimeout(() => {
                    this.hasErrors = false;
                }, 60000);
            }
        }
        
        async smartRefreshContainerLogs() {
            const logContentElement = document.getElementById('logContent');
            if (!logContentElement) return;
            
            // Preserve scroll position
            const logsContainer = document.getElementById('logsContainer');
            const wasAtBottom = logsContainer && 
                (logsContainer.scrollTop + logsContainer.clientHeight >= logsContainer.scrollHeight - 10);
            
            try {
                const response = await fetch(`/container_logs/${this.getCurrentContainerName()}`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const newContent = await response.text();
                const newHash = this.simpleHash(newContent);
                
                // Only update if content changed
                if (newHash !== this.lastContainerLogHash) {
                    this.lastContainerLogHash = newHash;
                    
                    // Parse and display logs
                    allRawLogs = this.parseLogs(newContent);
                    displayFilteredLogs();
                    
                    // Restore scroll position
                    if (wasAtBottom && logsContainer) {
                        setTimeout(() => {
                            logsContainer.scrollTop = logsContainer.scrollHeight;
                        }, 10);
                    }
                    
                    console.log('Container logs auto-refreshed (content changed)');
                }
            } catch (error) {
                console.warn('Container log auto-refresh failed:', error);
            }
        }
        
        async smartRefreshActionLogs() {
            const actionLogElement = document.getElementById('actionLogContent');
            if (!actionLogElement) return;
            
            try {
                const response = await fetch('/action_logs');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const newContent = await response.text();
                const newHash = this.simpleHash(newContent);
                
                // Only update if content changed
                if (newHash !== this.lastActionLogHash) {
                    this.lastActionLogHash = newHash;
                    actionLogElement.textContent = newContent;
                    console.log('Action logs auto-refreshed (content changed)');
                }
            } catch (error) {
                console.warn('Action log auto-refresh failed:', error);
            }
        }
        
        parseLogs(logText) {
            // Reuse existing log parsing logic
            return logText.split('\n').map(line => {
                const trimmed = line.trim();
                if (!trimmed) return { original: line, level: 'debug', display: line };
                
                let level = 'info';
                if (trimmed.includes('ERROR') || trimmed.includes('CRITICAL')) level = 'error';
                else if (trimmed.includes('WARNING') || trimmed.includes('WARN')) level = 'warning';
                else if (trimmed.includes('SUCCESS')) level = 'success';
                else if (trimmed.includes('DEBUG')) level = 'debug';
                
                return {
                    original: line,
                    level: level,
                    display: line
                };
            });
        }
        
        simpleHash(str) {
            // Simple hash function for change detection
            let hash = 0;
            if (str.length === 0) return hash;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return hash;
        }
        
        getCurrentContainerName() {
            // Get the current container name for log fetching
            // For DDC, we typically use the fixed container name
            return 'dockerdiscordcontrol';
        }
    }
    
    // Initialize auto-refresh when DOM is ready
    let logAutoRefresh = null;
    
    // Start auto-refresh after page load
    setTimeout(() => {
        logAutoRefresh = new LogAutoRefresh();
    }, 2000); // 2 second delay after page load

    // Diagnostics functionality for modal
    const runDiagnosticsModalBtn = document.getElementById('runDiagnosticsModalBtn');
    const diagnosticsModalLoader = document.getElementById('diagnosticsModalLoader');
    const diagnosticsModalResult = document.getElementById('diagnosticsModalResult');
    const diagnosticsModalContent = document.getElementById('diagnosticsModalContent');
    
    if (runDiagnosticsModalBtn) {
        runDiagnosticsModalBtn.addEventListener('click', async function() {
            try {
                // Show loader, hide button
                runDiagnosticsModalBtn.classList.add('d-none');
                diagnosticsModalLoader.classList.remove('d-none');
                diagnosticsModalResult.classList.add('d-none');
                
                const response = await fetch('/port_diagnostics');
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                
                const apiResponse = await response.json();
                if (!apiResponse.success) {
                    throw new Error(apiResponse.message || 'Diagnostics failed');
                }
                const diagnostics = apiResponse.diagnostics;
                
                // Build diagnostic report HTML
                let html = '';
                
                // Container Info
                html += `<div class="mb-3">
                    <h6>System Information</h6>
                    <strong>Container:</strong> ${diagnostics.container_name || 'Unknown'}<br>
                    <strong>Platform:</strong> ${diagnostics.host_info.platform} ${diagnostics.host_info.is_unraid ? '(Unraid)' : ''}<br>
                    <strong>Docker Environment:</strong> ${diagnostics.host_info.is_docker ? 'Yes' : 'No'}<br>
                    <strong>Docker Socket:</strong> <span class="badge ${diagnostics.host_info.docker_socket_available ? 'bg-success' : 'bg-danger'}">${diagnostics.host_info.docker_socket_available ? 'AVAILABLE' : 'NOT AVAILABLE'}</span><br>
                    <strong>Python Version:</strong> ${diagnostics.host_info.python_version || 'Unknown'}<br>
                    <strong>Container Uptime:</strong> ${diagnostics.host_info.container_uptime || 'Unknown'}
                </div>`;
                
                // Resource Usage
                html += `<div class="mb-3">
                    <h6>Resource Usage</h6>
                    <strong>System Memory:</strong> ${diagnostics.host_info.memory_usage || 'Unknown'}<br>
                    <strong>DDC Container Memory:</strong> ${diagnostics.host_info.ddc_memory_usage || 'Unknown'}<br>
                    <strong>DDC Image Size:</strong> ${diagnostics.host_info.ddc_image_size || 'Unknown'}<br>
                    <strong>Disk (/app):</strong> ${diagnostics.host_info.disk_usage || 'Unknown'}
                </div>`;
                
                // Process Status
                if (diagnostics.host_info.supervisord_status && Object.keys(diagnostics.host_info.supervisord_status).length > 0) {
                    html += '<div class="mb-3"><h6>Process Status</h6>';
                    
                    if (diagnostics.host_info.supervisord_status.error) {
                        html += `<span class="text-warning">${diagnostics.host_info.supervisord_status.error}</span>`;
                    } else {
                        for (const [process, status] of Object.entries(diagnostics.host_info.supervisord_status)) {
                            const statusClass = status === 'RUNNING' ? 'bg-success' : 'bg-danger';
                            html += `<strong>${process}:</strong> <span class="badge ${statusClass}">${status}</span><br>`;
                        }
                    }
                    html += '</div>';
                }
                
                // Port Status
                const portCheck = diagnostics.port_check;
                html += `<div class="mb-3">
                    <strong>Internal Web Port (9374):</strong> 
                    <span class="badge ${portCheck.internal_port_listening ? 'bg-success' : 'bg-danger'}">
                        ${portCheck.internal_port_listening ? 'LISTENING' : 'NOT LISTENING'}
                    </span>
                </div>`;
                
                // Port Mappings
                if (Object.keys(portCheck.port_mappings).length > 0) {
                    html += '<div class="mb-3"><strong>Port Mappings:</strong><ul>';
                    for (const [internal, external] of Object.entries(portCheck.port_mappings)) {
                        html += `<li>Internal ${internal}  External `;
                        if (Array.isArray(external)) {
                            html += external.map(e => typeof e === 'object' ? `${e.host}:${e.port}` : e).join(', ');
                        } else {
                            html += external;
                        }
                        html += '</li>';
                    }
                    html += '</ul></div>';
                } else {
                    html += '<div class="mb-3"><span class="text-warning"><strong>No port mappings detected</strong> - Web UI may not be accessible externally</span></div>';
                }
                
                // Issues
                if (portCheck.issues && portCheck.issues.length > 0) {
                    html += '<div class="mb-3"><h6 class="text-warning"> Issues Found:</h6><ul class="text-warning">';
                    portCheck.issues.forEach(issue => {
                        html += `<li>${issue}</li>`;
                    });
                    html += '</ul></div>';
                }
                
                // Solutions
                if (portCheck.solutions && portCheck.solutions.length > 0) {
                    html += '<div class="mb-3"><h6 class="text-info"> Suggested Solutions:</h6><ul class="text-info">';
                    portCheck.solutions.forEach(solution => {
                        html += `<li>${solution}</li>`;
                    });
                    html += '</ul></div>';
                }
                
                // Recommendations
                if (diagnostics.recommendations && diagnostics.recommendations.length > 0) {
                    html += '<div class="mb-3"><h6 class="text-success"> General Recommendations:</h6><ul class="text-light">';
                    diagnostics.recommendations.forEach(rec => {
                        html += `<li>${rec}</li>`;
                    });
                    html += '</ul></div>';
                }
                
                diagnosticsModalContent.innerHTML = html;
                diagnosticsModalResult.classList.remove('d-none');
                
            } catch (error) {
                console.error('Diagnostics error:', error);
                diagnosticsModalContent.innerHTML = `<div class="text-danger">
                    <strong>Error running diagnostics:</strong> ${error.message}
                    <br><small>Check browser console for details.</small>
                </div>`;
                diagnosticsModalResult.classList.remove('d-none');
            } finally {
                // Show button, hide loader
                diagnosticsModalLoader.classList.add('d-none');
                runDiagnosticsModalBtn.classList.remove('d-none');
            }
        });
    }
    
</script> 